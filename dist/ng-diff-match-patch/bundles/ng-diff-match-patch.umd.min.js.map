{"version":3,"sources":["ng://ng-diff-match-patch/lib/diffMatchPatch.ts","ng://ng-diff-match-patch/lib/diffMatchPatch.service.ts","null","ng://ng-diff-match-patch/lib/lineCompare.component.ts","ng://ng-diff-match-patch/lib/diff.directive.ts","ng://ng-diff-match-patch/lib/lineDiff.directive.ts","ng://ng-diff-match-patch/lib/processingDiff.directive.ts","ng://ng-diff-match-patch/lib/semanticDiff.directive.ts","ng://ng-diff-match-patch/lib/diffMatchPatch.module.ts"],"names":["DiffMatchPatch","RegExp","diffs","html","pattern_amp","pattern_lt","pattern_gt","pattern_para","x","length","op","text","replace","join","patches","patch_size","this","Match_MaxBits","length1","bigpatch","splice","start1","start2","precontext","patch","patch_obj","empty","length2","push","Patch_Margin","diff_type","diff_text","shift","substring","diff_text2","postcontext","diff_text1","prototype","diff_main","text1","text2","opt_checklines","opt_deadline","Diff_Timeout","Number","MAX_VALUE","Date","getTime","deadline","Error","checklines","commonlength","diff_commonPrefix","commonprefix","diff_commonSuffix","commonsuffix","diff_compute_","unshift","diff_cleanupMerge","longtext","shorttext","i","indexOf","hm","diff_halfMatch_","text1_a","text1_b","text2_a","text2_b","mid_common","diffs_a","diffs_b","concat","diff_lineMode_","diff_bisect_","a","diff_linesToChars_","chars1","chars2","linearray","lineArray","diff_charsToLines_","diff_cleanupSemantic","pointer","count_delete","count_insert","text_delete","text_insert","b","j","pop","text1_length","text2_length","max_d","Math","ceil","v_offset","v_length","v1","Array","v2","delta","front","k1start","k1end","k2start","k2end","d","k1","k1_offset","x1","y1","charAt","k2_offset","x2","diff_bisectSplit_","k2","y2","y","text1a","text2a","text1b","text2b","diffsb","lineHash","diff_linesToCharsMunge_","chars","lineStart","lineEnd","lineArrayLength","line","hasOwnProperty","undefined","String","fromCharCode","charCodeAt","pointermin","pointermax","min","pointermid","pointerstart","floor","pointerend","diff_commonOverlap_","text_length","best","pattern","found","hm1","diff_halfMatchI_","hm2","dmp","best_longtext_a","best_longtext_b","best_shorttext_a","best_shorttext_b","seed","best_common","prefixLength","suffixLength","changes","equalities","equalitiesLength","lastequality","length_insertions1","length_deletions1","length_insertions2","length_deletions2","max","diff_cleanupSemanticLossless","deletion","insertion","overlap_length1","overlap_length2","diff_cleanupSemanticScore_","one","two","nonAlphaNumericRegex_","char1","char2","nonAlphaNumeric1","match","nonAlphaNumeric2","whitespace1","whitespaceRegex_","whitespace2","lineBreak1","linebreakRegex_","lineBreak2","blankLine1","blanklineEndRegex_","blankLine2","blanklineStartRegex_","equality1","edit","equality2","commonOffset","commonString","bestEquality1","bestEdit","bestEquality2","bestScore","score","diff_cleanupEfficiency","pre_ins","pre_del","post_ins","post_del","Diff_EditCost","diff_xIndex","loc","last_chars1","last_chars2","diff_levenshtein","levenshtein","insertions","deletions","data","diff_toDelta","encodeURI","diff_fromDelta","diffsLength","tokens","split","param","decodeURI","ex","n","parseInt","isNaN","match_main","match_bitap_","s","match_alphabet_","match_bitapScore_","e","accuracy","proximity","abs","Match_Distance","score_threshold","Match_Threshold","best_loc","lastIndexOf","bin_min","bin_mid","matchmask","last_rd","bin_max","start","finish","rd","charMatch","patch_addContext_","padding","prefix","suffix","patch_make","opt_b","opt_c","patchDiffLength","char_count1","char_count2","prepatch_text","postpatch_text","patch_deepCopy","patchesCopy","patchCopy","patch_apply","nullPadding","patch_addPadding","patch_splitMax","results","expected_loc","start_loc","end_loc","Patch_DeleteThreshold","index1","index2","mod","paddingLength","extraLength","patch_toText","patch_fromText","textline","textPointer","patchHeader","m","sign","DiffMatchPatchService","ngOnInit","getDiff","left","right","getSemanticDiff","getProcessingDiff","getLineDiff","getDmp","Injectable","__values","o","Symbol","iterator","call","next","value","done","LineCompareComponent","updateHtml","ngOnChanges","toString","calculateLineDiff","diffCalculation","lines","lineLeft","lineRight","isContentEqual","calculatedDiff","diff","diffLines","isFirstDiff","isLastDiff","outputEqualDiff","outputDeleteDiff","outputInsertDiff","lineContextSize","lineIncrement","slice","outputEqualDiffLines","numberOfSkippedLines","diffLines_1","tslib_1.__values","diffLines_1_1","diffLines_2","diffLines_2_1","diffLines_3","diffLines_3_1","Component","args","selector","styles","template","Input","el","DiffDirective","nativeElement","innerHTML","createHtml","diffs_1","diffs_1_1","Directive","ElementRef","LineDiffDirective","ProcessingDiffDirective","SemanticDiffDirective","DiffMatchPatchModule","NgModule","declarations","imports","CommonModule","exports","providers"],"mappings":"+UAYA,IAAAA,EAAA,WAEE,SAAAA,sBAMe,qBAEC,uBAEE,uBAID,+BAKO,qBAET,qBAGC,yBAQG,IAAIC,OAAO,4BACZ,IAAIA,OAAO,oCACR,IAAIA,OAAO,wCACT,IAAIA,OAAO,sCAsnCd,SAASC,GAM3B,IALA,IAAMC,EAAO,GACPC,EAAc,KACdC,EAAa,KACbC,EAAa,KACbC,EAAe,MACZC,EAAI,EAAGA,EAAIN,EAAMO,OAAQD,IAAK,CACrC,IAAME,EAAKR,EAAMM,GAAG,GAEdG,EADOT,EAAMM,GAAG,GACJI,QAAQR,EAAa,SAASQ,QAAQP,EAAY,QAC/DO,QAAQN,EAAY,QAAQM,QAAQL,EAAc,cACvD,OAAQG,GACN,KAAA,EACEP,EAAKK,GAAK,oCAAsCG,EAAO,SACvD,MACF,KAAA,EACER,EAAKK,GAAK,oCAAsCG,EAAO,SACvD,MACF,KAAA,EACER,EAAKK,GAAK,SAAWG,EAAO,WAIlC,OAAOR,EAAKU,KAAK,yBA0rBA,SAASC,GAE1B,IADA,IAAMC,EAAaC,KAAKC,cACfT,EAAI,EAAGA,EAAIM,EAAQL,OAAQD,IAClC,KAAIM,EAAQN,GAAGU,SAAWH,GAA1B,CAGA,IAAMI,EAAWL,EAAQN,GAEzBM,EAAQM,OAAOZ,IAAK,GAIpB,IAHA,IAAIa,EAASF,EAASE,OAClBC,EAASH,EAASG,OAClBC,EAAa,GACgB,IAA1BJ,EAASjB,MAAMO,QAAc,CAElC,IAAMe,EAAQ,IAAIC,EACdC,GAAQ,EAOZ,IANAF,EAAMH,OAASA,EAASE,EAAWd,OACnCe,EAAMF,OAASA,EAASC,EAAWd,OAChB,KAAfc,IACFC,EAAMN,QAAUM,EAAMG,QAAUJ,EAAWd,OAC3Ce,EAAMtB,MAAM0B,KAAK,CAAA,EAAeL,KAED,IAA1BJ,EAASjB,MAAMO,QAChBe,EAAMN,QAAUH,EAAaC,KAAKa,cAAc,CACpD,IAAMC,EAAYX,EAASjB,MAAM,GAAG,GAChC6B,EAAYZ,EAASjB,MAAM,GAAG,GACrB,IAAT4B,GAEFN,EAAMG,SAAWI,EAAUtB,OAC3Ba,GAAUS,EAAUtB,OACpBe,EAAMtB,MAAM0B,KAAKT,EAASjB,MAAM8B,SAChCN,GAAQ,IACU,IAATI,GAAqD,GAAtBN,EAAMtB,MAAMO,QAC3B,GAAjBe,EAAMtB,MAAM,GAAG,IACf6B,EAAUtB,OAAS,EAAIM,GAE/BS,EAAMN,SAAWa,EAAUtB,OAC3BY,GAAUU,EAAUtB,OACpBiB,GAAQ,EACRF,EAAMtB,MAAM0B,KAAK,CAACE,EAAWC,IAC7BZ,EAASjB,MAAM8B,UAGfD,EAAYA,EAAUE,UAAU,EAC5BlB,EAAaS,EAAMN,QAAUF,KAAKa,cACtCL,EAAMN,SAAWa,EAAUtB,OAC3BY,GAAUU,EAAUtB,OACP,IAATqB,GACFN,EAAMG,SAAWI,EAAUtB,OAC3Ba,GAAUS,EAAUtB,QAEpBiB,GAAQ,EAEVF,EAAMtB,MAAM0B,KAAK,CAACE,EAAWC,IACzBA,GAAaZ,EAASjB,MAAM,GAAG,GACjCiB,EAASjB,MAAM8B,QAEfb,EAASjB,MAAM,GAAG,GACdiB,EAASjB,MAAM,GAAG,GAAG+B,UAAUF,EAAUtB,SAMnDc,GADAA,EAAaP,KAAKkB,WAAWV,EAAMtB,QAEpB+B,UAAUV,EAAWd,OAASO,KAAKa,cAElD,IAAMM,EAAcnB,KAAKoB,WAAWjB,EAASjB,OACtB+B,UAAU,EAAGjB,KAAKa,cACrB,KAAhBM,IACFX,EAAMN,SAAWiB,EAAY1B,OAC7Be,EAAMG,SAAWQ,EAAY1B,OACF,IAAvBe,EAAMtB,MAAMO,QAC0B,IAAtCe,EAAMtB,MAAMsB,EAAMtB,MAAMO,OAAS,GAAG,GACtCe,EAAMtB,MAAMsB,EAAMtB,MAAMO,OAAS,GAAG,IAAM0B,EAE1CX,EAAMtB,MAAM0B,KAAK,CAAA,EAAeO,KAG/BT,GACHZ,EAAQM,SAASZ,EAAG,EAAGgB,aAx4D7BxB,EAAAqC,UAAAC,UAAA,SAAWC,EAAeC,EAAeC,EAA0BC,QAEtC,IAAhBA,IAEPA,EADE1B,KAAK2B,cAAgB,EACRC,OAAOC,WAEP,IAAKC,MAAMC,UAAgC,IAApB/B,KAAK2B,cAG/C,IAAMK,EAAWN,EAGjB,GAAa,MAATH,GAA0B,MAATC,EACnB,MAAM,IAAIS,MAAM,2BAIlB,GAAIV,GAASC,EACX,OAAID,EACK,CAAC,CAAA,EAAeA,IAElB,QAGoB,IAAlBE,IACTA,GAAiB,GAEnB,IAAMS,EAAaT,EAGfU,EAAenC,KAAKoC,kBAAkBb,EAAOC,GAC3Ca,EAAed,EAAMN,UAAU,EAAGkB,GACxCZ,EAAQA,EAAMN,UAAUkB,GACxBX,EAAQA,EAAMP,UAAUkB,GAGxBA,EAAenC,KAAKsC,kBAAkBf,EAAOC,GAC7C,IAAMe,EAAehB,EAAMN,UAAUM,EAAM9B,OAAS0C,GACpDZ,EAAQA,EAAMN,UAAU,EAAGM,EAAM9B,OAAS0C,GAC1CX,EAAQA,EAAMP,UAAU,EAAGO,EAAM/B,OAAS0C,GAG1C,IAAMjD,EAAQc,KAAKwC,cAAcjB,EAAOC,EAAOU,EAAYF,GAU3D,OAPIK,GACFnD,EAAMuD,QAAQ,CAAA,EAAeJ,IAE3BE,GACFrD,EAAM0B,KAAK,CAAA,EAAe2B,IAE5BvC,KAAK0C,kBAAkBxD,GAChBA,GAgBTF,EAAAqC,UAAAmB,cAAA,SAAejB,EAAeC,EAAeU,EAC3CF,GACF,IAAI9C,EAEJ,IAAKqC,EAEH,MAAO,CAAC,CAAA,EAAgBC,IAG1B,IAAKA,EAEH,MAAO,CAAC,EAAA,EAAgBD,IAG1B,IAAMoB,EAAWpB,EAAM9B,OAAS+B,EAAM/B,OAAS8B,EAAQC,EACjDoB,EAAYrB,EAAM9B,OAAS+B,EAAM/B,OAAS+B,EAAQD,EAClDsB,EAAIF,EAASG,QAAQF,GAC3B,IAAU,GAANC,EASF,OAPA3D,EAAQ,CAAC,CAAA,EAAgByD,EAAS1B,UAAU,EAAG4B,IACvC,CAAA,EAAeD,GACf,CAAA,EAAgBD,EAAS1B,UAAU4B,EAAID,EAAUnD,UAErD8B,EAAM9B,OAAS+B,EAAM/B,SACvBP,EAAM,GAAG,GAAKA,EAAM,GAAG,IAAE,GAEpBA,EAGT,GAAwB,GAApB0D,EAAUnD,OAGZ,MAAO,CAAC,EAAA,EAAgB8B,GAAQ,CAAA,EAAgBC,IAIlD,IAAMuB,EAAK/C,KAAKgD,gBAAgBzB,EAAOC,GACvC,GAAIuB,EAAI,CAEN,IAAME,EAAUF,EAAG,GACbG,EAAUH,EAAG,GACbI,EAAUJ,EAAG,GACbK,EAAUL,EAAG,GACbM,EAAaN,EAAG,GAEhBO,EAAUtD,KAAKsB,UAAU2B,EAASE,EAASjB,EAAYF,GACvDuB,EAAUvD,KAAKsB,UAAU4B,EAASE,EAASlB,EAAYF,GAE7D,OAAOsB,EAAQE,OAAO,CAAC,CAAA,EAAeH,IAAcE,GAGtD,OAAIrB,GAA6B,IAAfX,EAAM9B,QAA+B,IAAf+B,EAAM/B,OACrCO,KAAKyD,eAAelC,EAAOC,EAAOQ,GAGpChC,KAAK0D,aAAanC,EAAOC,EAAOQ,IAcvChD,EAAAqC,UAAAoC,eAAA,SAAgBlC,EAAeC,EAAeQ,GAE9C,IAAM2B,EAAI3D,KAAK4D,mBAAmBrC,EAAOC,GACzCD,EAAQoC,EAAEE,OACVrC,EAAQmC,EAAEG,OACV,IAAMC,EAAYJ,EAAEK,UAEd9E,EAAQc,KAAKsB,UAAUC,EAAOC,GAAO,EAAOQ,GAGlDhC,KAAKiE,mBAAmB/E,EAAO6E,GAE/B/D,KAAKkE,qBAAqBhF,GAI1BA,EAAM0B,KAAK,CAAA,EAAe,KAM1B,IALA,IAAIuD,EAAU,EACVC,EAAe,EACfC,EAAe,EACfC,EAAc,GACdC,EAAc,GACXJ,EAAUjF,EAAMO,QAAQ,CAC7B,OAAQP,EAAMiF,GAAS,IACrB,KAAA,EACEE,IACAE,GAAerF,EAAMiF,GAAS,GAC9B,MACF,KAAA,EACEC,IACAE,GAAepF,EAAMiF,GAAS,GAC9B,MACF,KAAA,EAEE,GAAoB,GAAhBC,GAAqC,GAAhBC,EAAmB,CAE1CnF,EAAMkB,OAAO+D,EAAUC,EAAeC,EAC1BD,EAAeC,GAC3BF,EAAUA,EAAUC,EAAeC,EAEnC,IADA,IAAMG,EAAIxE,KAAKsB,UAAUgD,EAAaC,GAAa,EAAOvC,GACjDyC,EAAID,EAAE/E,OAAS,EAAQ,GAALgF,EAAQA,IACjCvF,EAAMkB,OAAO+D,EAAS,EAAGK,EAAEC,IAE7BN,GAAoBK,EAAE/E,OAGxB2E,EADAC,EAAe,EAGfE,EADAD,EAAc,GAIlBH,IAIF,OAFAjF,EAAMwF,MAECxF,GAcPF,EAAAqC,UAAAqC,aAAA,SAAcnC,EAAeC,EAAeQ,GAW5C,IATA,IAAM2C,EAAepD,EAAM9B,OACrBmF,EAAepD,EAAM/B,OACrBoF,EAAQC,KAAKC,MAAMJ,EAAeC,GAAgB,GAClDI,EAAWH,EACXI,EAAW,EAAIJ,EACfK,EAAK,IAAIC,MAAMF,GACfG,EAAK,IAAID,MAAMF,GAGZzF,EAAI,EAAGA,EAAIyF,EAAUzF,IAC5B0F,EAAG1F,IAAM,EACT4F,EAAG5F,IAAM,EAEX0F,EAAGF,EAAW,GAAK,EAYnB,IAVA,IAAMK,EAAQV,EAAeC,EAGvBU,EAASD,EAAQ,IAJvBD,EAAGJ,EAAW,GAAK,GAOfO,EAAU,EACVC,EAAQ,EACRC,EAAU,EACVC,EAAQ,EACHC,EAAI,EAAGA,EAAId,MAEd,IAAK/C,MAAQC,UAAYC,GAFJ2D,IAAK,CAO9B,IAAK,IAAIC,GAAMD,EAAIJ,EAASK,GAAMD,EAAIH,EAAOI,GAAM,EAAG,CASpD,IARA,IAAMC,EAAYb,EAAWY,EACzBE,OAAE,EAMFC,GAJFD,EADEF,IAAOD,GAAMC,GAAMD,GAAKT,EAAGW,EAAY,GAAKX,EAAGW,EAAY,GACxDX,EAAGW,EAAY,GAEfX,EAAGW,EAAY,GAAK,GAEbD,EACPE,EAAKnB,GAAgBoB,EAAKnB,GAC3BrD,EAAMyE,OAAOF,IAAOtE,EAAMwE,OAAOD,IACrCD,IACAC,IAGF,GAASpB,GADTO,EAAGW,GAAaC,GAGdN,GAAS,OACJ,GAASZ,EAALmB,EAETR,GAAW,OACN,GAAID,EAAO,CAEhB,GAAiB,IADXW,EAAYjB,EAAWK,EAAQO,IACfK,EAAYhB,IAA8B,GAAlBG,EAAGa,GAG/C,IADMC,EAAKvB,EAAeS,EAAGa,KACzBH,EAEF,OAAO9F,KAAKmG,kBAAkB5E,EAAOC,EAAOsE,EAAIC,EAAI/D,IAO5D,IAAK,IAAIoE,GAAMT,EAAIF,EAASW,GAAMT,EAAID,EAAOU,GAAM,EAAG,CASpD,IARA,IAAMH,EAAYjB,EAAWoB,EACzBF,OAAE,EAMFG,GAJFH,EADEE,IAAOT,GAAMS,GAAMT,GAAKP,EAAGa,EAAY,GAAKb,EAAGa,EAAY,GACxDb,EAAGa,EAAY,GAEfb,EAAGa,EAAY,GAAK,GAEbG,EACPF,EAAKvB,GAAgB0B,EAAKzB,GAC3BrD,EAAMyE,OAAOrB,EAAeuB,EAAK,IACjC1E,EAAMwE,OAAOpB,EAAeyB,EAAK,IACrCH,IACAG,IAGF,GAAS1B,GADTS,EAAGa,GAAaC,GAGdR,GAAS,OACJ,GAASd,EAALyB,EAETZ,GAAW,OACN,IAAKH,EAAO,CAEjB,GAAiB,IADXO,EAAYb,EAAWK,EAAQe,IACfP,EAAYZ,IAA8B,GAAlBC,EAAGW,GAAkB,CAE3DE,EAAKf,GADLc,EAAKZ,EAAGW,IACaA,EAG3B,IADAK,EAAKvB,EAAeuB,IAChBJ,EAEF,OAAO9F,KAAKmG,kBAAkB5E,EAAOC,EAAOsE,EAAIC,EAAI/D,MAQ9D,MAAO,CAAC,EAAA,EAAgBT,GAAQ,CAAA,EAAgBC,KAehDxC,EAAAqC,UAAA8E,kBAAA,SAAmB5E,EAAeC,EAAehC,EAAW8G,EAAWtE,GACrE,IAAMuE,EAAShF,EAAMN,UAAU,EAAGzB,GAC5BgH,EAAShF,EAAMP,UAAU,EAAGqF,GAC5BG,EAASlF,EAAMN,UAAUzB,GACzBkH,EAASlF,EAAMP,UAAUqF,GAGzBpH,EAAQc,KAAKsB,UAAUiF,EAAQC,GAAQ,EAAOxE,GAC9C2E,EAAS3G,KAAKsB,UAAUmF,EAAQC,GAAQ,EAAO1E,GAErD,OAAO9C,EAAMsE,OAAOmD,IAetB3H,EAAAqC,UAAAuC,mBAAA,SAAoBrC,EAAeC,GACjC,IAAMwC,EAAY,GACZ4C,EAAW,GASjB,OALA5C,EAAU,GAAK,GAKR,CAACH,OAFO7D,KAAK6G,wBAAwBtF,EAAOyC,EAAW4C,GAEtC9C,OADT9D,KAAK6G,wBAAwBrF,EAAOwC,EAAW4C,GACtB5C,UAAWA,IAWvDhF,EAAAqC,UAAAwF,wBAAA,SAAwBlH,EAAcqE,EAA0B4C,GAS9D,IARA,IAAIE,EAAQ,GAIRC,EAAY,EACZC,GAAW,EAEXC,EAAkBjD,EAAUvE,OACzBuH,EAAUrH,EAAKF,OAAS,GAAG,EAEhB,IADhBuH,EAAUrH,EAAKmD,QAAQ,KAAMiE,MAE3BC,EAAUrH,EAAKF,OAAS,GAE1B,IAAMyH,EAAOvH,EAAKsB,UAAU8F,EAAWC,EAAU,GACjDD,EAAYC,EAAU,GAElBJ,EAASO,eAAiBP,EAASO,eAAeD,GACjDN,EAASM,KAAUE,WACtBN,GAASO,OAAOC,aAAaV,EAASM,KAEtCJ,GAASO,OAAOC,aAAaL,GAC7BL,EAASM,GAAQD,EACjBjD,EAAUiD,KAAqBC,GAGnC,OAAOJ,GAUP9H,EAAAqC,UAAA4C,mBAAA,SAAoB/E,EAAoB8E,GACxC,IAAK,IAAIxE,EAAI,EAAGA,EAAIN,EAAMO,OAAQD,IAAK,CAGrC,IAFA,IAAMsH,EAAQ5H,EAAMM,GAAG,GACjBG,EAAO,GACJ2G,EAAI,EAAGA,EAAIQ,EAAMrH,OAAQ6G,IAChC3G,EAAK2G,GAAKtC,EAAU8C,EAAMS,WAAWjB,IAEvCpH,EAAMM,GAAG,GAAKG,EAAKE,KAAK,MAY1Bb,EAAAqC,UAAAe,kBAAA,SAAmBb,EAAeC,GAElC,IAAKD,IAAUC,GAASD,EAAMyE,OAAO,IAAMxE,EAAMwE,OAAO,GACtD,OAAO,EAQT,IAJA,IAAIwB,EAAa,EACbC,EAAa3C,KAAK4C,IAAInG,EAAM9B,OAAQ+B,EAAM/B,QAC1CkI,EAAaF,EACbG,EAAe,EACZJ,EAAaG,GACdpG,EAAMN,UAAU2G,EAAcD,IAC9BnG,EAAMP,UAAU2G,EAAcD,GAEhCC,EADAJ,EAAaG,EAGbF,EAAaE,EAEfA,EAAa7C,KAAK+C,OAAOJ,EAAaD,GAAc,EAAIA,GAE1D,OAAOG,GAUP3I,EAAAqC,UAAAiB,kBAAA,SAAmBf,EAAeC,GAElC,IAAKD,IAAUC,GACXD,EAAMyE,OAAOzE,EAAM9B,OAAS,IAAM+B,EAAMwE,OAAOxE,EAAM/B,OAAS,GAChE,OAAO,EAQT,IAJA,IAAI+H,EAAa,EACbC,EAAa3C,KAAK4C,IAAInG,EAAM9B,OAAQ+B,EAAM/B,QAC1CkI,EAAaF,EACbK,EAAa,EACVN,EAAaG,GACdpG,EAAMN,UAAUM,EAAM9B,OAASkI,EAAYpG,EAAM9B,OAASqI,IAC1DtG,EAAMP,UAAUO,EAAM/B,OAASkI,EAAYnG,EAAM/B,OAASqI,GAE5DA,EADAN,EAAaG,EAGbF,EAAaE,EAEfA,EAAa7C,KAAK+C,OAAOJ,EAAaD,GAAc,EAAIA,GAE1D,OAAOG,GAYP3I,EAAAqC,UAAA0G,oBAAA,SAAqBxG,EAAeC,GAEpC,IAAMmD,EAAepD,EAAM9B,OACrBmF,EAAepD,EAAM/B,OAE3B,GAAoB,GAAhBkF,GAAqC,GAAhBC,EACvB,OAAO,EAGUA,EAAfD,EACFpD,EAAQA,EAAMN,UAAU0D,EAAeC,GAC9BD,EAAeC,IACxBpD,EAAQA,EAAMP,UAAU,EAAG0D,IAE7B,IAAMqD,EAAclD,KAAK4C,IAAI/C,EAAcC,GAE3C,GAAIrD,GAASC,EACX,OAAOwG,EAQT,IAFA,IAAIC,EAAO,EACPxI,EAAS,IACA,CACX,IAAMyI,EAAU3G,EAAMN,UAAU+G,EAAcvI,GACxC0I,EAAQ3G,EAAMsB,QAAQoF,GAC5B,IAAc,GAAVC,EACF,OAAOF,EAETxI,GAAU0I,EACG,GAATA,GAAc5G,EAAMN,UAAU+G,EAAcvI,IAC5C+B,EAAMP,UAAU,EAAGxB,KACrBwI,EAAOxI,EACPA,OAiBJT,EAAAqC,UAAA2B,gBAAA,SAAiBzB,EAAeC,GAChC,GAAIxB,KAAK2B,cAAgB,EAEvB,OAAO,KAET,IAAMgB,EAAWpB,EAAM9B,OAAS+B,EAAM/B,OAAS8B,EAAQC,EACjDoB,EAAYrB,EAAM9B,OAAS+B,EAAM/B,OAAS+B,EAAQD,EACxD,GAAIoB,EAASlD,OAAS,GAAwB,EAAnBmD,EAAUnD,OAAakD,EAASlD,OACzD,OAAO,KAET,IASIsD,EAaAE,EAASC,EAASC,EAASC,EAlBzBgF,EAAMpI,KAAKqI,iBAAiB1F,EAAUC,EAClBkC,KAAKC,KAAKpC,EAASlD,OAAS,GAL1CO,MAONsI,EAAMtI,KAAKqI,iBAAiB1F,EAAUC,EAClBkC,KAAKC,KAAKpC,EAASlD,OAAS,GAR1CO,MAUZ,OAAKoI,GAAQE,GAQXvF,EANUuF,EAEAF,GAILA,EAAI,GAAG3I,OAAS6I,EAAI,GAAG7I,OAAS2I,EAHhCE,EAFAF,EAUH7G,EAAM9B,OAAS+B,EAAM/B,QACvBwD,EAAUF,EAAG,GACbG,EAAUH,EAAG,GACbI,EAAUJ,EAAG,GACbK,EAAUL,EAAG,KAEbI,EAAUJ,EAAG,GACbK,EAAUL,EAAG,GACbE,EAAUF,EAAG,GACbG,EAAUH,EAAG,IAGR,CAACE,EAASC,EAASC,EAASC,EADhBL,EAAG,KAvBb,MAuCX/D,EAAAqC,UAAAgH,iBAAA,SAAiB1F,EAAkBC,EAAmBC,EAAW0F,GAM/D,IAJA,IAGIC,EAAiBC,EAAiBC,EAAkBC,EAHlDC,EAAOjG,EAAS1B,UAAU4B,EAAGA,EAAIiC,KAAK+C,MAAMlF,EAASlD,OAAS,IAChEgF,GAAK,EACLoE,EAAc,IAE8B,IAAxCpE,EAAI7B,EAAUE,QAAQ8F,EAAMnE,EAAI,KAAW,CACjD,IAAMqE,EAAeP,EAAInG,kBAAkBO,EAAS1B,UAAU4B,GACtBD,EAAU3B,UAAUwD,IACtDsE,EAAeR,EAAIjG,kBAAkBK,EAAS1B,UAAU,EAAG4B,GACzBD,EAAU3B,UAAU,EAAGwD,IAC3DoE,EAAYpJ,OAASsJ,EAAeD,IACtCD,EAAcjG,EAAU3B,UAAUwD,EAAIsE,EAActE,GAChD7B,EAAU3B,UAAUwD,EAAGA,EAAIqE,GAC/BN,EAAkB7F,EAAS1B,UAAU,EAAG4B,EAAIkG,GAC5CN,EAAkB9F,EAAS1B,UAAU4B,EAAIiG,GACzCJ,EAAmB9F,EAAU3B,UAAU,EAAGwD,EAAIsE,GAC9CJ,EAAmB/F,EAAU3B,UAAUwD,EAAIqE,IAG/C,OAAyB,EAArBD,EAAYpJ,QAAckD,EAASlD,OAC9B,CAAC+I,EAAiBC,EACjBC,EAAkBC,EAAkBE,GAErC,MAQT7J,EAAAqC,UAAA6C,qBAAA,SAAsBhF,GActB,IAbA,IAAI8J,GAAU,EACRC,EAAa,GACfC,EAAmB,EAEnBC,EAAe,KAEfhF,EAAU,EAEViF,EAAqB,EACrBC,EAAoB,EAEpBC,EAAqB,EACrBC,EAAoB,EACjBpF,EAAUjF,EAAMO,QACA,GAAjBP,EAAMiF,GAAS,IAEjBiF,EAAqBE,EACrBD,EAAoBE,EAEpBA,EADAD,EAAqB,EAErBH,EAAejK,EALf+J,EAAWC,KAAsB/E,GAKH,KAET,GAAjBjF,EAAMiF,GAAS,GACjBmF,GAAsBpK,EAAMiF,GAAS,GAAG1E,OAExC8J,GAAqBrK,EAAMiF,GAAS,GAAG1E,OAIrC0J,GAAiBA,EAAa1J,QAC9BqF,KAAK0E,IAAIJ,EAAoBC,IAC5BF,EAAa1J,QAAUqF,KAAK0E,IAAIF,EACDC,KAElCrK,EAAMkB,OAAO6I,EAAWC,EAAmB,GAAI,EACnC,EAAA,EAAgBC,IAE5BjK,EAAM+J,EAAWC,EAAmB,GAAK,GAAG,GAAE,EAE9CA,IAGA/E,EAA6B,IAD7B+E,EACiCD,EAAWC,EAAmB,IAAM,EAIrEK,EADAD,EADAD,EADAD,EAAqB,EAKrBJ,IADAG,EAAe,QAInBhF,IAgBF,IAZI6E,GACFhJ,KAAK0C,kBAAkBxD,GAEzBc,KAAKyJ,6BAA6BvK,GAQlCiF,EAAU,EACHA,EAAUjF,EAAMO,QAAQ,CAC7B,IAAyB,GAArBP,EAAMiF,EAAU,GAAG,IACF,GAAjBjF,EAAMiF,GAAS,GAAqB,CACtC,IAAMuF,EAAWxK,EAAMiF,EAAU,GAAG,GAC9BwF,EAAYzK,EAAMiF,GAAS,GAC3ByF,EAAkB5J,KAAK+H,oBAAoB2B,EAAUC,GACrDE,EAAkB7J,KAAK+H,oBAAoB4B,EAAWD,GACrCG,GAAnBD,GACEA,GAAmBF,EAASjK,OAAS,GACrCmK,GAAmBD,EAAUlK,OAAS,KAExCP,EAAMkB,OAAO+D,EAAS,EAClB,CAAA,EAAewF,EAAU1I,UAAU,EAAG2I,KAC1C1K,EAAMiF,EAAU,GAAG,GACfuF,EAASzI,UAAU,EAAGyI,EAASjK,OAASmK,GAC5C1K,EAAMiF,EAAU,GAAG,GAAKwF,EAAU1I,UAAU2I,GAC5CzF,MAGE0F,GAAmBH,EAASjK,OAAS,GACrCoK,GAAmBF,EAAUlK,OAAS,KAGxCP,EAAMkB,OAAO+D,EAAS,EAClB,CAAA,EAAeuF,EAASzI,UAAU,EAAG4I,KACzC3K,EAAMiF,EAAU,GAAG,GAAE,EACrBjF,EAAMiF,EAAU,GAAG,GACfwF,EAAU1I,UAAU,EAAG0I,EAAUlK,OAASoK,GAC9C3K,EAAMiF,EAAU,GAAG,IAAE,EACrBjF,EAAMiF,EAAU,GAAG,GACfuF,EAASzI,UAAU4I,GACvB1F,KAGJA,IAEFA,MAWFnF,EAAAqC,UAAAoI,6BAAA,SAA8BvK,GAW9B,SAAA4K,EAAoCC,EAAaC,GAC/C,IAAKD,IAAQC,EAEX,OAAO,EAIT,IAAMC,EAAwB,IAAIhL,OAAO,kBAOnCiL,EAAQH,EAAI/D,OAAO+D,EAAItK,OAAS,GAChC0K,EAAQH,EAAIhE,OAAO,GACnBoE,EAAmBF,EAAMG,MAAMJ,GAC/BK,EAAmBH,EAAME,MAAMJ,GAC/BM,EAAcH,GAChBF,EAAMG,MAAMrK,KAAKwK,kBACfC,EAAcH,GAChBH,EAAME,MAAMrK,KAAKwK,kBACfE,EAAaH,GACfL,EAAMG,MAAMrK,KAAK2K,iBACfC,EAAaH,GACfN,EAAME,MAAMrK,KAAK2K,iBACfE,EAAaH,GACfX,EAAIM,MAAMrK,KAAK8K,oBACbC,EAAaH,GACfZ,EAAIK,MAAMrK,KAAKgL,sBAEnB,OAAIH,GAAcE,EAET,EACEL,GAAcE,EAEhB,EACER,IAAqBG,GAAeE,EAEtC,EACEF,GAAeE,EAEjB,EACEL,GAAoBE,EAEtB,EAEF,EAKT,IAFA,IAAInG,EAAU,EAEPA,EAAUjF,EAAMO,OAAS,GAAG,CACjC,GAAyB,GAArBP,EAAMiF,EAAU,GAAG,IACE,GAArBjF,EAAMiF,EAAU,GAAG,GAAoB,CAEzC,IAAI8G,EAAY/L,EAAMiF,EAAU,GAAG,GAC/B+G,EAAOhM,EAAMiF,GAAS,GACtBgH,EAAYjM,EAAMiF,EAAU,GAAG,GAG7BiH,EAAepL,KAAKsC,kBAAkB2I,EAAWC,GACvD,GAAIE,EAAc,CAChB,IAAMC,EAAeH,EAAKjK,UAAUiK,EAAKzL,OAAS2L,GAClDH,EAAYA,EAAUhK,UAAU,EAAGgK,EAAUxL,OAAS2L,GACtDF,EAAOG,EAAeH,EAAKjK,UAAU,EAAGiK,EAAKzL,OAAS2L,GACtDD,EAAYE,EAAeF,EAS7B,IALA,IAAIG,EAAgBL,EAChBM,EAAWL,EACXM,EAAgBL,EAChBM,EAAY3B,EAA2BmB,EAAWC,GAClDpB,EAA2BoB,EAAMC,GAC9BD,EAAKlF,OAAO,KAAOmF,EAAUnF,OAAO,IAAI,CAC7CiF,GAAaC,EAAKlF,OAAO,GACzBkF,EAAOA,EAAKjK,UAAU,GAAKkK,EAAUnF,OAAO,GAC5CmF,EAAYA,EAAUlK,UAAU,GAChC,IAAMyK,EAAQ5B,EAA2BmB,EAAWC,GAChDpB,EAA2BoB,EAAMC,GAExBM,GAATC,IACFD,EAAYC,EACZJ,EAAgBL,EAChBM,EAAWL,EACXM,EAAgBL,GAIhBjM,EAAMiF,EAAU,GAAG,IAAMmH,IAEvBA,EACFpM,EAAMiF,EAAU,GAAG,GAAKmH,GAExBpM,EAAMkB,OAAO+D,EAAU,EAAG,GAC1BA,KAEFjF,EAAMiF,GAAS,GAAKoH,EAChBC,EACFtM,EAAMiF,EAAU,GAAG,GAAKqH,GAExBtM,EAAMkB,OAAO+D,EAAU,EAAG,GAC1BA,MAINA,MASFnF,EAAAqC,UAAAsK,uBAAA,SAAwBzM,GAgBxB,IAfA,IAAI8J,GAAU,EACRC,EAAa,GACfC,EAAmB,EAEnBC,EAAe,KAEfhF,EAAU,EAEVyH,GAAU,EAEVC,GAAU,EAEVC,GAAW,EAEXC,GAAW,EACR5H,EAAUjF,EAAMO,QACA,GAAjBP,EAAMiF,GAAS,IACbjF,EAAMiF,GAAS,GAAG1E,OAASO,KAAKgM,gBAC/BF,GAAYC,IAGfH,EAAUE,EACVD,EAAUE,EACV5C,EAAejK,EAHf+J,EAAWC,KAAsB/E,GAGH,KAG9B+E,EAAmB,EACnBC,EAAe,MAEjB2C,EAAWC,GAAW,KAED,GAAjB7M,EAAMiF,GAAS,GACjB4H,GAAW,EAEXD,GAAW,EAUT3C,IAAkByC,GAAWC,GAAWC,GAAYC,GAClC5C,EAAa1J,OAASO,KAAKgM,cAAgB,IAC3CJ,EAAQ,EAAE,IAAMC,EAAQ,EAAE,IAAMC,EAAS,EAAE,IAAMC,EAAS,EAAE,IAAM,KAEtF7M,EAAMkB,OAAO6I,EAAWC,EAAmB,GAAI,EACnC,EAAA,EAAgBC,IAE5BjK,EAAM+J,EAAWC,EAAmB,GAAK,GAAG,GAAE,EAC9CA,IACAC,EAAe,KACXyC,GAAWC,GAEbC,EAAWC,GAAW,EACtB7C,EAAmB,IAGnB/E,EAA6B,IAD7B+E,EAEID,EAAWC,EAAmB,IAAM,EACxC4C,EAAWC,GAAW,GAExB/C,GAAU,IAGd7E,IAGE6E,GACFhJ,KAAK0C,kBAAkBxD,IAUzBF,EAAAqC,UAAAqB,kBAAA,SAAmBxD,GACnBA,EAAM0B,KAAK,CAAA,EAAe,KAO1B,IANA,IAKIuB,EALAgC,EAAU,EACVC,EAAe,EACfC,EAAe,EACfC,EAAc,GACdC,EAAc,GAEXJ,EAAUjF,EAAMO,QACrB,OAAQP,EAAMiF,GAAS,IACrB,KAAA,EACEE,IACAE,GAAerF,EAAMiF,GAAS,GAC9BA,IACA,MACF,KAAA,EACEC,IACAE,GAAepF,EAAMiF,GAAS,GAC9BA,IACA,MACF,KAAA,EAEoC,EAA9BC,EAAeC,GACI,IAAjBD,GAAuC,IAAjBC,IAGH,KADrBlC,EAAenC,KAAKoC,kBAAkBmC,EAAaD,MAEH,EAAzCH,EAAUC,EAAeC,MAC1BnF,EAAMiF,EAAUC,EAAeC,EAAe,GAAG,GAEnDnF,EAAMiF,EAAUC,EAAeC,EAAe,GAAG,IAC7CE,EAAYtD,UAAU,EAAGkB,IAE7BjD,EAAMkB,OAAO,EAAG,EAAG,CAAA,EACCmE,EAAYtD,UAAU,EAAGkB,KAC7CgC,KAEFI,EAAcA,EAAYtD,UAAUkB,GACpCmC,EAAcA,EAAYrD,UAAUkB,IAIjB,KADrBA,EAAenC,KAAKsC,kBAAkBiC,EAAaD,MAEjDpF,EAAMiF,GAAS,GAAKI,EAAYtD,UAAUsD,EAAY9E,OAClD0C,GAAgBjD,EAAMiF,GAAS,GACnCI,EAAcA,EAAYtD,UAAU,EAAGsD,EAAY9E,OAC/C0C,GACJmC,EAAcA,EAAYrD,UAAU,EAAGqD,EAAY7E,OAC/C0C,KAIa,IAAjBiC,EACFlF,EAAMkB,OAAO+D,EAAUE,EACnBD,EAAeC,EAAc,CAAA,EAAgBE,IACvB,IAAjBF,EACTnF,EAAMkB,OAAO+D,EAAUC,EACnBA,EAAeC,EAAc,EAAA,EAAgBC,IAEjDpF,EAAMkB,OAAO+D,EAAUC,EAAeC,EAClCD,EAAeC,EAAc,EAAA,EAAgBC,GAC7C,CAAA,EAAgBC,IAEtBJ,EAAUA,EAAUC,EAAeC,GACxBD,EAAe,EAAI,IAAMC,EAAe,EAAI,GAAK,GACvC,IAAZF,GAAsC,GAArBjF,EAAMiF,EAAU,GAAG,IAE7CjF,EAAMiF,EAAU,GAAG,IAAMjF,EAAMiF,GAAS,GACxCjF,EAAMkB,OAAO+D,EAAS,IAEtBA,IAGFC,EADAC,EAAe,EAGfE,EADAD,EAAc,GAKe,KAA/BpF,EAAMA,EAAMO,OAAS,GAAG,IAC1BP,EAAMwF,MAMR,IAAIsE,GAAU,EAGd,IAFA7E,EAAU,EAEHA,EAAUjF,EAAMO,OAAS,GACL,GAArBP,EAAMiF,EAAU,GAAG,IACE,GAArBjF,EAAMiF,EAAU,GAAG,KAEjBjF,EAAMiF,GAAS,GAAGlD,UAAU/B,EAAMiF,GAAS,GAAG1E,OAC9CP,EAAMiF,EAAU,GAAG,GAAG1E,SAAWP,EAAMiF,EAAU,GAAG,IAEtDjF,EAAMiF,GAAS,GAAKjF,EAAMiF,EAAU,GAAG,GACnCjF,EAAMiF,GAAS,GAAGlD,UAAU,EAAG/B,EAAMiF,GAAS,GAAG1E,OACrBP,EAAMiF,EAAU,GAAG,GAAG1E,QACtDP,EAAMiF,EAAU,GAAG,GAAKjF,EAAMiF,EAAU,GAAG,GAAKjF,EAAMiF,EAAU,GAAG,GACnEjF,EAAMkB,OAAO+D,EAAU,EAAG,GAC1B6E,GAAU,GACD9J,EAAMiF,GAAS,GAAGlD,UAAU,EAAG/B,EAAMiF,EAAU,GAAG,GAAG1E,SAC5DP,EAAMiF,EAAU,GAAG,KAErBjF,EAAMiF,EAAU,GAAG,IAAMjF,EAAMiF,EAAU,GAAG,GAC5CjF,EAAMiF,GAAS,GACXjF,EAAMiF,GAAS,GAAGlD,UAAU/B,EAAMiF,EAAU,GAAG,GAAG1E,QAClDP,EAAMiF,EAAU,GAAG,GACvBjF,EAAMkB,OAAO+D,EAAU,EAAG,GAC1B6E,GAAU,IAGd7E,IAGE6E,GACFhJ,KAAK0C,kBAAkBxD,IAazBF,EAAAqC,UAAA4K,YAAA,SAAa/M,EAAoBgN,GACjC,IAII1M,EAJAqE,EAAS,EACTC,EAAS,EACTqI,EAAc,EACdC,EAAc,EAElB,IAAK5M,EAAI,EAAGA,EAAIN,EAAMO,SACL,IAAXP,EAAMM,GAAG,KACXqE,GAAU3E,EAAMM,GAAG,GAAGC,SAET,IAAXP,EAAMM,GAAG,KACXsE,GAAU5E,EAAMM,GAAG,GAAGC,UAEXyM,EAATrI,IAPwBrE,IAU5B2M,EAActI,EACduI,EAActI,EAGhB,OAAI5E,EAAMO,QAAUD,IAAgB,IAAXN,EAAMM,GAAG,GACzB4M,EAGFA,GAAeF,EAAMC,IAyC5BnN,EAAAqC,UAAAD,WAAA,SAAYlC,GAEZ,IADA,IAAMS,EAAO,GACJH,EAAI,EAAGA,EAAIN,EAAMO,OAAQD,IACjB,IAAXN,EAAMM,GAAG,KACXG,EAAKH,GAAKN,EAAMM,GAAG,IAGvB,OAAOG,EAAKE,KAAK,KASjBb,EAAAqC,UAAAH,WAAA,SAAYhC,GAEZ,IADA,IAAMS,EAAO,GACJH,EAAI,EAAGA,EAAIN,EAAMO,OAAQD,KACjB,IAAXN,EAAMM,GAAG,KACXG,EAAKH,GAAKN,EAAMM,GAAG,IAGvB,OAAOG,EAAKE,KAAK,KAUjBb,EAAAqC,UAAAgL,iBAAA,SAAkBnN,GAIlB,IAHA,IAAIoN,EAAc,EACdC,EAAa,EACbC,EAAY,EACPhN,EAAI,EAAGA,EAAIN,EAAMO,OAAQD,IAAK,CACrC,IAAME,EAAKR,EAAMM,GAAG,GACdiN,EAAOvN,EAAMM,GAAG,GACtB,OAAQE,GACN,KAAA,EACE6M,GAAcE,EAAKhN,OACnB,MACF,KAAA,EACE+M,GAAaC,EAAKhN,OAClB,MACF,KAAA,EAEE6M,GAAexH,KAAK0E,IAAI+C,EAAYC,GAEpCA,EADAD,EAAa,GAMnB,OADAD,GAAexH,KAAK0E,IAAI+C,EAAYC,IAapCxN,EAAAqC,UAAAqL,aAAA,SAAcxN,GAEd,IADA,IAAMS,EAAO,GACJH,EAAI,EAAGA,EAAIN,EAAMO,OAAQD,IAChC,OAAQN,EAAMM,GAAG,IACf,KAAA,EACEG,EAAKH,GAAK,IAAMmN,UAAUzN,EAAMM,GAAG,IACnC,MACF,KAAA,EACEG,EAAKH,GAAK,IAAMN,EAAMM,GAAG,GAAGC,OAC5B,MACF,KAAA,EACEE,EAAKH,GAAK,IAAMN,EAAMM,GAAG,GAAGC,OAIlC,OAAOE,EAAKE,KAAK,MAAMD,QAAQ,OAAQ,MAYvCZ,EAAAqC,UAAAuL,eAAA,SAAgBrL,EAAe8D,GAK/B,IAJA,IAAMnG,EAAQ,GACV2N,EAAc,EACd1I,EAAU,EACR2I,EAASzH,EAAM0H,MAAM,OAClBvN,EAAI,EAAGA,EAAIsN,EAAOrN,OAAQD,IAAK,CAGtC,IAAMwN,EAAQF,EAAOtN,GAAGyB,UAAU,GAClC,OAAQ6L,EAAOtN,GAAGwG,OAAO,IACvB,IAAK,IACH,IACE9G,EAAM2N,KAAiB,CAAA,EAAgBI,UAAUD,IACjD,MAAOE,GAEP,MAAM,IAAIjL,MAAM,qCAAuC+K,GAEzD,MACF,IAAK,IAEL,IAAK,IACH,IAAMG,EAAIC,SAASJ,EAAO,IAC1B,GAAIK,MAAMF,IAAMA,EAAI,EAClB,MAAM,IAAIlL,MAAM,qCAAuC+K,GAEzD,IAAMrN,EAAO4B,EAAMN,UAAUkD,EAASA,GAAWgJ,GACtB,KAAvBL,EAAOtN,GAAGwG,OAAO,GACnB9G,EAAM2N,KAAiB,CAAA,EAAelN,GAEtCT,EAAM2N,KAAiB,EAAA,EAAgBlN,GAEzC,MACF,QAGE,GAAImN,EAAOtN,GACT,MAAM,IAAIyC,MAAM,6CACA6K,EAAOtN,KAI/B,GAAI2E,GAAW5C,EAAM9B,OACnB,MAAM,IAAIwC,MAAM,iBAAmBkC,EAC/B,wCAA0C5C,EAAM9B,OAAS,MAE/D,OAAOP,GAUPF,EAAAqC,UAAAiM,WAAA,SAAY3N,EAAcuI,EAAiBgE,GAE3C,GAAY,MAARvM,GAA2B,MAAXuI,GAA0B,MAAPgE,EACrC,MAAM,IAAIjK,MAAM,4BAIlB,OADAiK,EAAMpH,KAAK0E,IAAI,EAAG1E,KAAK4C,IAAIwE,EAAKvM,EAAKF,SACjCE,GAAQuI,EAEH,EACGvI,EAAKF,OAGNE,EAAKsB,UAAUiL,EAAKA,EAAMhE,EAAQzI,SAAWyI,EAE/CgE,EAGAlM,KAAKuN,aAAa5N,EAAMuI,EAASgE,IANhC,GAoBVlN,EAAAqC,UAAAkM,aAAA,SAAc5N,EAAcuI,EAAiBgE,GAC7C,GAAIhE,EAAQzI,OAASO,KAAKC,cACxB,MAAM,IAAIgC,MAAM,sCAIlB,IAAMuL,EAAIxN,KAAKyN,gBAAgBvF,GAEzBK,EAAMvI,KAUZ,SAAA0N,EAA2BC,EAAWnO,GACpC,IAAMoO,EAAWD,EAAIzF,EAAQzI,OACvBoO,EAAY/I,KAAKgJ,IAAI5B,EAAM1M,GACjC,OAAK+I,EAAIwF,eAIFH,EAAYC,EAAYtF,EAAIwF,eAF1BF,EAAY,EAAMD,EAM7B,IAAII,EAAkBhO,KAAKiO,gBAEvBC,EAAWvO,EAAKmD,QAAQoF,EAASgE,IACpB,GAAbgC,IACFF,EAAkBlJ,KAAK4C,IAAIgG,EAAkB,EAAGQ,GAAWF,IAG1C,IADjBE,EAAWvO,EAAKwO,YAAYjG,EAASgE,EAAMhE,EAAQzI,WAEjDuO,EACIlJ,KAAK4C,IAAIgG,EAAkB,EAAGQ,GAAWF,KAKjD,IAGII,EAASC,EAHPC,EAAY,GAAMpG,EAAQzI,OAAS,EACzCyO,GAAY,EAKZ,IAFA,IACIK,EADAC,EAAUtG,EAAQzI,OAASE,EAAKF,OAE3BkG,EAAI,EAAGA,EAAIuC,EAAQzI,OAAQkG,IAAK,CAMvC,IAFAyI,EAAU,EACVC,EAAUG,EACHJ,EAAUC,GACXX,EAAkB/H,EAAGuG,EAAMmC,IAAYL,EACzCI,EAAUC,EAEVG,EAAUH,EAEZA,EAAUvJ,KAAK+C,OAAO2G,EAAUJ,GAAW,EAAIA,GAGjDI,EAAUH,EACV,IAAII,EAAQ3J,KAAK0E,IAAI,EAAG0C,EAAMmC,EAAU,GAClCK,EAAS5J,KAAK4C,IAAIwE,EAAMmC,EAAS1O,EAAKF,QAAUyI,EAAQzI,OAExDkP,EAAKxJ,MAAMuJ,EAAS,GAC1BC,EAAGD,EAAS,IAAM,GAAK/I,GAAK,EAC5B,IAAK,IAAIlB,EAAIiK,EAAaD,GAALhK,EAAYA,IAAK,CAGpC,IAAMmK,EAAYpB,EAAE7N,EAAKqG,OAAOvB,EAAI,IAQpC,GANEkK,EAAGlK,GADK,IAANkB,GACQgJ,EAAGlK,EAAI,IAAM,EAAK,GAAKmK,GAEtBD,EAAGlK,EAAI,IAAM,EAAK,GAAKmK,GACvBL,EAAQ9J,EAAI,GAAK8J,EAAQ9J,KAAO,EAAK,EACxC8J,EAAQ9J,EAAI,GAElBkK,EAAGlK,GAAK6J,EAAW,CACrB,IAAM5C,EAAQgC,EAAkB/H,EAAGlB,EAAI,GAGvC,GAAIiH,GAASsC,EAAiB,CAI5B,GAFAA,EAAkBtC,IAEHQ,GADfgC,EAAWzJ,EAAI,IAMb,MAHAgK,EAAQ3J,KAAK0E,IAAI,EAAG,EAAI0C,EAAMgC,KAStC,GAAIR,EAAkB/H,EAAI,EAAGuG,GAAO8B,EAClC,MAEFO,EAAUI,EAEZ,OAAOT,GAUPlP,EAAAqC,UAAAoM,gBAAA,SAAiBvF,GAEjB,IADA,IAAMsF,EAAqC,GAClC3K,EAAI,EAAGA,EAAIqF,EAAQzI,OAAQoD,IAClC2K,EAAEtF,EAAQlC,OAAOnD,IAAM,EAEzB,IAASA,EAAI,EAAGA,EAAIqF,EAAQzI,OAAQoD,IAClC2K,EAAEtF,EAAQlC,OAAOnD,KAAO,GAAMqF,EAAQzI,OAASoD,EAAI,EAErD,OAAO2K,GAWPxO,EAAAqC,UAAAwN,kBAAA,SAAmBrO,EAAkBb,GACrC,GAAmB,GAAfA,EAAKF,OAAT,CAQA,IALA,IAAIyI,EAAUvI,EAAKsB,UAAUT,EAAMF,OAAQE,EAAMF,OAASE,EAAMN,SAC5D4O,EAAU,EAIPnP,EAAKmD,QAAQoF,IAAYvI,EAAKwO,YAAYjG,IAC3CA,EAAQzI,OAASO,KAAKC,cAAgBD,KAAKa,aAC3Cb,KAAKa,cACTiO,GAAW9O,KAAKa,aAChBqH,EAAUvI,EAAKsB,UAAUT,EAAMF,OAASwO,EAChBtO,EAAMF,OAASE,EAAMN,QAAU4O,GAGzDA,GAAW9O,KAAKa,aAGhB,IAAMkO,EAASpP,EAAKsB,UAAUT,EAAMF,OAASwO,EAAStO,EAAMF,QACxDyO,GACFvO,EAAMtB,MAAMuD,QAAQ,CAAA,EAAesM,IAGrC,IAAMC,EAASrP,EAAKsB,UAAUT,EAAMF,OAASE,EAAMN,QACvBM,EAAMF,OAASE,EAAMN,QAAU4O,GACvDE,GACFxO,EAAMtB,MAAM0B,KAAK,CAAA,EAAeoO,IAIlCxO,EAAMH,QAAU0O,EAAOtP,OACvBe,EAAMF,QAAUyO,EAAOtP,OAEvBe,EAAMN,SAAW6O,EAAOtP,OAASuP,EAAOvP,OACxCe,EAAMG,SAAWoO,EAAOtP,OAASuP,EAAOvP,SA0BxCT,EAAAqC,UAAA4N,WAAA,SAAYtL,EAAyBuL,EAA6BC,GAClE,IAAI5N,EAAOrC,EACX,GAAgB,iBAALyE,GAAiC,iBAATuL,QACf,IAATC,EAGT5N,EAAK,EAEc,GADnBrC,EAAQc,KAAKsB,UAAUC,EAAK,GAAW,IAC7B9B,SACRO,KAAKkE,qBAAqBhF,GAC1Bc,KAAK2L,uBAAuBzM,SAEzB,GAAIyE,GAAiB,iBAALA,QAAiC,IAATuL,QAC3B,IAATC,EAGTjQ,EAAK,EACLqC,EAAQvB,KAAKoB,WAAWlC,QACnB,GAAgB,iBAALyE,GAAiBuL,GAAyB,iBAATA,QAC/B,IAATC,EAET5N,EAAK,EACLrC,EAAK,MACA,CAAA,GAAgB,iBAALyE,GAAiC,iBAATuL,IACtCC,GAAyB,iBAATA,EAMlB,MAAM,IAAIlN,MAAM,sCAHhBV,EAAK,EACLrC,EAAK,EAKP,GAAqB,IAAjBA,EAAMO,OACR,MAAO,GAYT,IAVA,IAAMK,EAAU,GACZU,EAAQ,IAAIC,EACZ2O,EAAkB,EAClBC,EAAc,EACdC,EAAc,EAIdC,EAAgBhO,EAChBiO,EAAiBjO,EACZ/B,EAAI,EAAGA,EAAIN,EAAMO,OAAQD,IAAK,CACrC,IAAMsB,EAAY5B,EAAMM,GAAG,GACrBuB,EAAY7B,EAAMM,GAAG,GAQ3B,OANK4P,GAA4B,IAATtO,IAEtBN,EAAMH,OAASgP,EACf7O,EAAMF,OAASgP,GAGTxO,GACN,KAAA,EACEN,EAAMtB,MAAMkQ,KAAqBlQ,EAAMM,GACvCgB,EAAMG,SAAWI,EAAUtB,OAC3B+P,EAAiBA,EAAevO,UAAU,EAAGqO,GAAevO,EAC5CyO,EAAevO,UAAUqO,GACzC,MACF,KAAA,EACE9O,EAAMN,SAAWa,EAAUtB,OAC3Be,EAAMtB,MAAMkQ,KAAqBlQ,EAAMM,GACvCgQ,EAAiBA,EAAevO,UAAU,EAAGqO,GAC7BE,EAAevO,UAAUqO,EACrBvO,EAAUtB,QAC9B,MACF,KAAA,EACMsB,EAAUtB,QAAU,EAAIO,KAAKa,cAC7BuO,GAAmBlQ,EAAMO,QAAUD,EAAI,GAEzCgB,EAAMtB,MAAMkQ,KAAqBlQ,EAAMM,GACvCgB,EAAMN,SAAWa,EAAUtB,OAC3Be,EAAMG,SAAWI,EAAUtB,QAClBsB,EAAUtB,QAAU,EAAIO,KAAKa,cAElCuO,IACFpP,KAAK6O,kBAAkBrO,EAAO+O,GAC9BzP,EAAQc,KAAKJ,GACbA,EAAQ,IAAIC,EACZ2O,EAAkB,EAKlBG,EAAgBC,EAChBH,EAAcC,GAOT,IAATxO,IACFuO,GAAetO,EAAUtB,SAEd,IAATqB,IACFwO,GAAevO,EAAUtB,QAS7B,OALI2P,IACFpP,KAAK6O,kBAAkBrO,EAAO+O,GAC9BzP,EAAQc,KAAKJ,IAGRV,GASPd,EAAAqC,UAAAoO,eAAA,SAAgB3P,GAGhB,IADA,IAAM4P,EAAc,GACXlQ,EAAI,EAAGA,EAAIM,EAAQL,OAAQD,IAAK,CACvC,IAAMgB,EAAQV,EAAQN,GAChBmQ,EAAY,IAAIlP,EACtBkP,EAAUzQ,MAAQ,GAClB,IAAK,IAAIoH,EAAI,EAAGA,EAAI9F,EAAMtB,MAAMO,OAAQ6G,IACtCqJ,EAAUzQ,MAAMoH,GAAK,CAAC9F,EAAMtB,MAAMoH,GAAG,GAAI9F,EAAMtB,MAAMoH,GAAG,IAE1DqJ,EAAUtP,OAASG,EAAMH,OACzBsP,EAAUrP,OAASE,EAAMF,OACzBqP,EAAUzP,QAAUM,EAAMN,QAC1ByP,EAAUhP,QAAUH,EAAMG,QAC1B+O,EAAYlQ,GAAKmQ,EAEnB,OAAOD,GAYP1Q,EAAAqC,UAAAuO,YAAA,SAAa9P,EAA2BH,GACxC,GAAsB,GAAlBG,EAAQL,OACV,MAAO,CAACE,EAAM,IAIhBG,EAAUE,KAAKyP,eAAe3P,GAE9B,IAAM+P,EAAc7P,KAAK8P,iBAAiBhQ,GAC1CH,EAAOkQ,EAAclQ,EAAOkQ,EAE5B7P,KAAK+P,eAAejQ,GAOpB,IAFA,IAAIuF,EAAQ,EACN2K,EAAU,GACPxQ,EAAI,EAAGA,EAAIM,EAAQL,OAAQD,IAAK,CACvC,IAAMyQ,EAAenQ,EAAQN,GAAGc,OAAS+E,EACnC9D,EAAQvB,KAAKoB,WAAWtB,EAAQN,GAAGN,OACrCgR,OAAS,EACTC,GAAW,EAkBf,GAjBI5O,EAAM9B,OAASO,KAAKC,eAKJ,IAFlBiQ,EAAYlQ,KAAKsN,WAAW3N,EAAM4B,EAAMN,UAAU,EAAGjB,KAAKC,eAC9BgQ,OAKV,IAHhBE,EAAUnQ,KAAKsN,WAAW3N,EACtB4B,EAAMN,UAAUM,EAAM9B,OAASO,KAAKC,eACpCgQ,EAAe1O,EAAM9B,OAASO,KAAKC,iBACLkQ,GAAbD,KAEnBA,GAAa,GAIjBA,EAAYlQ,KAAKsN,WAAW3N,EAAM4B,EAAO0O,IAEzB,GAAdC,EAEFF,EAAQxQ,IAAK,EAEb6F,GAASvF,EAAQN,GAAGmB,QAAUb,EAAQN,GAAGU,YACpC,CAEL8P,EAAQxQ,IAAK,EACb6F,EAAQ6K,EAAYD,EACpB,IAAIzO,OAAK,EAMT,GAAID,IAJFC,GADc,GAAZ2O,EACMxQ,EAAKsB,UAAUiP,EAAWA,EAAY3O,EAAM9B,QAE5CE,EAAKsB,UAAUiP,EAAWC,EAAUnQ,KAAKC,gBAIjDN,EAAOA,EAAKsB,UAAU,EAAGiP,GACnBlQ,KAAKkB,WAAWpB,EAAQN,GAAGN,OAC3BS,EAAKsB,UAAUiP,EAAY3O,EAAM9B,YAClC,CAGL,IAAMP,EAAQc,KAAKsB,UAAUC,EAAOC,GAAO,GAC3C,GAAID,EAAM9B,OAASO,KAAKC,eACpBD,KAAKqM,iBAAiBnN,GAASqC,EAAM9B,OACrCO,KAAKoQ,sBAEPJ,EAAQxQ,IAAK,MACR,CACLQ,KAAKyJ,6BAA6BvK,GAGlC,IAFA,IAAImR,EAAS,EACTC,OAAM,EACDhK,EAAI,EAAGA,EAAIxG,EAAQN,GAAGN,MAAMO,OAAQ6G,IAAK,CAChD,IAAMiK,EAAMzQ,EAAQN,GAAGN,MAAMoH,GACnB,IAANiK,EAAI,KACND,EAAStQ,KAAKiM,YAAY/M,EAAOmR,IAEzB,IAANE,EAAI,GACN5Q,EAAOA,EAAKsB,UAAU,EAAGiP,EAAYI,GAAUC,EAAI,GAC7C5Q,EAAKsB,UAAUiP,EAAYI,IAClB,IAANC,EAAI,KACb5Q,EAAOA,EAAKsB,UAAU,EAAGiP,EAAYI,GAC/B3Q,EAAKsB,UAAUiP,EAAYlQ,KAAKiM,YAAY/M,EACxCmR,EAASE,EAAI,GAAG9Q,WAElB,IAAN8Q,EAAI,KACNF,GAAUE,EAAI,GAAG9Q,YAS7B,MAAO,CADPE,EAAOA,EAAKsB,UAAU4O,EAAYpQ,OAAQE,EAAKF,OAASoQ,EAAYpQ,QACtDuQ,IAUdhR,EAAAqC,UAAAyO,iBAAA,SAAkBhQ,GAGlB,IAFA,IAAM0Q,EAAgBxQ,KAAKa,aACvBgP,EAAc,GACTrQ,EAAI,EAAGA,GAAKgR,EAAehR,IAClCqQ,GAAexI,OAAOC,aAAa9H,GAIrC,IAASA,EAAI,EAAGA,EAAIM,EAAQL,OAAQD,IAClCM,EAAQN,GAAGa,QAAUmQ,EACrB1Q,EAAQN,GAAGc,QAAUkQ,EAIvB,IAAIhQ,EAAQV,EAAQ,GAChBZ,EAAQsB,EAAMtB,MAClB,GAAoB,GAAhBA,EAAMO,QAA0B,GAAXP,EAAM,GAAG,GAEhCA,EAAMuD,QAAQ,CAAA,EAAeoN,IAC7BrP,EAAMH,QAAUmQ,EAChBhQ,EAAMF,QAAUkQ,EAChBhQ,EAAMN,SAAWsQ,EACjBhQ,EAAMG,SAAW6P,OACZ,GAAIA,EAAgBtR,EAAM,GAAG,GAAGO,OAAQ,CAE7C,IAAMgR,EAAcD,EAAgBtR,EAAM,GAAG,GAAGO,OAChDP,EAAM,GAAG,GAAK2Q,EAAY5O,UAAU/B,EAAM,GAAG,GAAGO,QAAUP,EAAM,GAAG,GACnEsB,EAAMH,QAAUoQ,EAChBjQ,EAAMF,QAAUmQ,EAChBjQ,EAAMN,SAAWuQ,EACjBjQ,EAAMG,SAAW8P,EAMnB,GAAoB,IADpBvR,GADAsB,EAAQV,EAAQA,EAAQL,OAAS,IACnBP,OACJO,QAAyC,GAA1BP,EAAMA,EAAMO,OAAS,GAAG,GAE/CP,EAAM0B,KAAK,CAAA,EAAeiP,IAC1BrP,EAAMN,SAAWsQ,EACjBhQ,EAAMG,SAAW6P,OACZ,GAAIA,EAAgBtR,EAAMA,EAAMO,OAAS,GAAG,GAAGA,OAAQ,CAEtDgR,EAAcD,EAAgBtR,EAAMA,EAAMO,OAAS,GAAG,GAAGA,OAC/DP,EAAMA,EAAMO,OAAS,GAAG,IAAMoQ,EAAY5O,UAAU,EAAGwP,GACvDjQ,EAAMN,SAAWuQ,EACjBjQ,EAAMG,SAAW8P,EAGnB,OAAOZ,GAsGP7Q,EAAAqC,UAAAqP,aAAA,SAAc5Q,GAEd,IADA,IAAMH,EAAO,GACJH,EAAI,EAAGA,EAAIM,EAAQL,OAAQD,IAClCG,EAAKH,GAAKM,EAAQN,GAEpB,OAAOG,EAAKE,KAAK,KAUjBb,EAAAqC,UAAAsP,eAAA,SAAgBC,GAChB,IAAM9Q,EAA4B,GAClC,IAAK8Q,EACH,OAAO9Q,EAKT,IAHA,IAAMH,EAAOiR,EAAS7D,MAAM,MACxB8D,EAAc,EACZC,EAAc,uCACbD,EAAclR,EAAKF,QAAQ,CAChC,IAAMsR,EAAIpR,EAAKkR,GAAaxG,MAAMyG,GAClC,IAAKC,EACH,MAAM,IAAI9O,MAAM,yBAA2BtC,EAAKkR,IAElD,IAAMrQ,EAAQ,IAAIC,EAyBlB,IAxBAX,EAAQc,KAAKJ,GACbA,EAAMH,OAAS+M,SAAS2D,EAAE,GAAI,IACjB,KAATA,EAAE,IACJvQ,EAAMH,SACNG,EAAMN,QAAU,GACC,KAAR6Q,EAAE,GACXvQ,EAAMN,QAAU,GAEhBM,EAAMH,SACNG,EAAMN,QAAUkN,SAAS2D,EAAE,GAAI,KAGjCvQ,EAAMF,OAAS8M,SAAS2D,EAAE,GAAI,IACjB,KAATA,EAAE,IACJvQ,EAAMF,SACNE,EAAMG,QAAU,GACC,KAARoQ,EAAE,GACXvQ,EAAMG,QAAU,GAEhBH,EAAMF,SACNE,EAAMG,QAAUyM,SAAS2D,EAAE,GAAI,KAEjCF,IAEOA,EAAclR,EAAKF,QAAQ,CAChC,IAAMuR,EAAOrR,EAAKkR,GAAa7K,OAAO,GAClCkB,OAAI,EACR,IACEA,EAAO+F,UAAUtN,EAAKkR,GAAa5P,UAAU,IAC7C,MAAOiM,GAEP,MAAM,IAAIjL,MAAM,qCAAuCiF,GAEzD,GAAY,KAAR8J,EAEFxQ,EAAMtB,MAAM0B,KAAK,EAAA,EAAgBsG,SAC5B,GAAY,KAAR8J,EAETxQ,EAAMtB,MAAM0B,KAAK,CAAA,EAAgBsG,SAC5B,GAAY,KAAR8J,EAETxQ,EAAMtB,MAAM0B,KAAK,CAAA,EAAesG,QAC3B,CAAA,GAAY,KAAR8J,EAET,MACK,GAAa,KAATA,EAIT,MAAM,IAAI/O,MAAM,uBAAyB+O,EAAO,SAAW9J,GAE7D2J,KAGJ,OAAO/Q,KA3hEX,GAqiEAW,EAEE,sBAEqB,eACJ,iBACA,kBACC,eACA,gBAOP,WAmBT,IAlBA,IAgBIf,EADEC,EAAO,CAAC,QAdO,IAAjBK,KAAKE,QACGF,KAAKK,OAAS,KACC,GAAhBL,KAAKE,QACJF,KAAKK,OAAS,EAEbL,KAAKK,OAAS,EAAK,IAAML,KAAKE,SASV,MAPZ,IAAjBF,KAAKW,QACGX,KAAKM,OAAS,KACC,GAAhBN,KAAKW,QACJX,KAAKM,OAAS,EAEbN,KAAKM,OAAS,EAAK,IAAMN,KAAKW,SAEO,SAGzCnB,EAAI,EAAGA,EAAIQ,KAAKd,MAAMO,OAAQD,IAAK,CAC1C,OAAQQ,KAAKd,MAAMM,GAAG,IACpB,KAAA,EACEE,EAAK,IACL,MACF,KAAA,EACEA,EAAK,IACL,MACF,KAAA,EACEA,EAAK,IAGTC,EAAKH,EAAI,GAAKE,EAAKiN,UAAU3M,KAAKd,MAAMM,GAAG,IAAM,KAEnD,OAAOG,EAAKE,KAAK,IAAID,QAAQ,OAAQ,OCjmEzCqR,EAAA,WAME,SAAAA,EAAoB1I,GAAAvI,KAAAuI,IAAAA,SAEpB0I,EAAA5P,UAAA6P,SAAA,aAIAD,EAAA5P,UAAA8P,QAAA,SAAQC,EAAcC,GACnB,OAAOrR,KAAKuI,IAAIjH,UAAU8P,EAAMC,IAGnCJ,EAAA5P,UAAAiQ,gBAAA,SAAgBF,EAAcC,GAC5B,IAAMnS,EAAQc,KAAKuI,IAAIjH,UAAU8P,EAAMC,GAEvC,OADArR,KAAKuI,IAAIrE,qBAAqBhF,GACvBA,GAGT+R,EAAA5P,UAAAkQ,kBAAA,SAAkBH,EAAcC,GAC9B,IAAMnS,EAAQc,KAAKuI,IAAIjH,UAAU8P,EAAMC,GAEvC,OADArR,KAAKuI,IAAIoD,uBAAuBzM,GACzBA,GAGT+R,EAAA5P,UAAAmQ,YAAA,SAAYJ,EAAcC,GACxB,IAAMvK,EAAQ9G,KAAKuI,IAAI3E,mBAAmBwN,EAAMC,GAC1CnS,EAAQc,KAAKuI,IAAIjH,UAAUwF,EAAMjD,OAAQiD,EAAMhD,QAAQ,GAE7D,OADA9D,KAAKuI,IAAItE,mBAAmB/E,EAAO4H,EAAM9C,WAClC9E,GAGT+R,EAAA5P,UAAAoQ,OAAA,WACE,OAAOzR,KAAKuI,yBAjCfmJ,EAAAA,sDAFQ1S,OADT,GCcA,SAAA2S,EA4FyBC,GACrB,IAAIb,EAAsB,mBAAXc,QAAyBD,EAAEC,OAAOC,UAAWjP,EAAI,EAChE,OAAIkO,EAAUA,EAAEgB,KAAKH,GACd,CACHI,KAAM,WAEF,OADIJ,GAAK/O,GAAK+O,EAAEnS,SAAQmS,OAAI,GACrB,CAAEK,MAAOL,GAAKA,EAAE/O,KAAMqP,MAAON,iCCgBlCrJ,GAAAvI,KAAAuI,IAAAA,YAZ6B,cAEC,UAYnC4J,EAAA9Q,UAAA6P,oBACLlR,KAAKoS,cAGAD,EAAA9Q,UAAAgR,uBACLrS,KAAKoS,cAGCD,EAAA9Q,UAAA+Q,sBACmB,iBAAdpS,KAAKoR,MAA0C,kBAAdpR,KAAKoR,OAC/CpR,KAAKoR,KAAOpR,KAAKoR,KAAKkB,YAEE,iBAAftS,KAAKqR,OAA4C,kBAAfrR,KAAKqR,QAChDrR,KAAKqR,MAAQrR,KAAKqR,MAAMiB,YAE1BtS,KAAKuS,kBAAkBvS,KAAKuI,IAAIiJ,YAAYxR,KAAKoR,KAAMpR,KAAKqR,SAGtDc,EAAA9Q,UAAAkR,2BAAkBrT,GACxB,IAAMsT,EAAmC,CACvCC,MAAO,GACPC,SAAU,EACVC,UAAW,GAIb,GADA3S,KAAK4S,eAAkC,IAAjB1T,EAAMO,QAA2B,IAAXP,EAAM,GAAG,GACjDc,KAAK4S,eACP5S,KAAK6S,eAAiB,OADxB,CAKA,IAAK,IAAIhQ,EAAI,EAAGA,EAAI3D,EAAMO,OAAQoD,IAAK,CACrC,IAAMiQ,EAAO5T,EAAM2D,GACfkQ,EAAsBD,EAAK,GAAG/F,MAAM,SAQxC,OAJ8C,GAA1CgG,EAAUA,EAAUtT,OAAS,GAAGA,QAClCsT,EAAUrO,MAGJoO,EAAK,IACX,KAAA,EACE,IAAME,EAAoB,IAANnQ,EACdoQ,EAAapQ,IAAM3D,EAAMO,OAAS,EACxCO,KAAKkT,gBAAgBH,EAAWP,EAAiBQ,EAAaC,GAC9D,MAEF,KAAA,EACEjT,KAAKmT,iBAAiBJ,EAAWP,GACjC,MAEF,KAAA,EACExS,KAAKoT,iBAAiBL,EAAWP,IAMvCxS,KAAK6S,eAAiBL,EAAgBC,QAiBhCN,EAAA9Q,UAAA6R,yBACJH,EACAP,EACAQ,EACAC,GACF,GAAIjT,KAAKqT,iBAAmBN,EAAUtT,OAASO,KAAKqT,gBAClD,GAAIL,EAAa,CAEf,IAAMM,EAAgBP,EAAUtT,OAASO,KAAKqT,gBAC9Cb,EAAgBE,UAAYY,EAC5Bd,EAAgBG,WAAaW,EAC7BP,EAAYA,EAAUQ,MAAMR,EAAUtT,OAASO,KAAKqT,gBAAiBN,EAAUtT,aAE5E,GAAIwT,EAEPF,EAAYA,EAAUQ,MAAM,EAAGvT,KAAKqT,sBAEjC,GAAIN,EAAUtT,OAAS,EAAIO,KAAKqT,gBAAiB,CAEpDrT,KAAKwT,qBAAqBT,EAAUQ,MAAM,EAAGvT,KAAKqT,iBAAkBb,GAGpEA,EAAgBC,MAAM7R,KAAK,CAAC,yBAA0B,MAAO,MAAO,QACpE,IAAM6S,EAAuBV,EAAUtT,OAAU,EAAIO,KAAKqT,gBAQ1D,OAPAb,EAAgBE,UAAYe,EAC5BjB,EAAgBG,WAAac,OAG7BzT,KAAKwT,qBAAqBT,EAAUQ,MAAMR,EAAUtT,OAASO,KAAKqT,iBAAkBb,GAMxFxS,KAAKwT,qBAAqBT,EAAWP,IAG/BL,EAAA9Q,UAAAmS,8BACJT,EACAP,OACF,IAAmB,IAAAkB,EAAAC,EAAAZ,GAASa,EAAAF,EAAA1B,QAAA4B,EAAA1B,KAAA0B,EAAAF,EAAA1B,OAAA,CAAvB,IAAM9K,EAAI0M,EAAA3B,MACbO,EAAgBC,MAAM7R,KAAK,CAAC,yBAA0B,GAAG4R,EAAgBE,SAAY,GAAGF,EAAgBG,UAAazL,IACrHsL,EAAgBE,WAChBF,EAAgBG,0HAIZR,EAAA9Q,UAAA8R,0BACJJ,EACAP,OACF,IAAmB,IAAAqB,EAAAF,EAAAZ,GAASe,EAAAD,EAAA7B,QAAA8B,EAAA5B,KAAA4B,EAAAD,EAAA7B,OAAA,CAAvB,IAAM9K,EAAI4M,EAAA7B,MACbO,EAAgBC,MAAM7R,KAAK,CAAC,0BAA2B,GAAG4R,EAAgBE,SAAY,IAAKxL,IAC3FsL,EAAgBE,yHAIZP,EAAA9Q,UAAA+R,0BACJL,EACAP,OACF,IAAmB,IAAAuB,EAAAJ,EAAAZ,GAASiB,EAAAD,EAAA/B,QAAAgC,EAAA9B,KAAA8B,EAAAD,EAAA/B,OAAA,CAAvB,IAAM9K,EAAI8M,EAAA/B,MACbO,EAAgBC,MAAM7R,KAAK,CAAC,0BAA2B,IAAK,GAAG4R,EAAgBG,UAAazL,IAC5FsL,EAAgBG,8IA5PrBsB,EAAAA,UAASC,KAAA,CAAC,CACTC,SAAU,mBACVC,OAAQ,CAAC,67DA2ETC,SAAU,46BA1FHpD,mCAiHNqD,EAAAA,qBAEAA,EAAAA,+BAIAA,EAAAA,sCC5GSC,EACAhM,GADAvI,KAAAuU,GAAAA,EACAvU,KAAAuI,IAAAA,YALc,cACC,UAMlBiM,EAAAnT,UAAA6P,oBACLlR,KAAKoS,cAGAoC,EAAAnT,UAAAgR,uBACLrS,KAAKoS,cAGCoC,EAAAnT,UAAA+Q,sBACNpS,KAAKuU,GAAGE,cAAcC,UAAY1U,KAAK2U,WACrC3U,KAAKuI,IAAI4I,QAAQnR,KAAKoR,KAAMpR,KAAKqR,SAG7BmD,EAAAnT,UAAAsT,oBAAWzV,GACjB,IAAIC,MACJA,EAAO,YACP,IAAgB,IAAAyV,EAAAjB,EAAAzU,GAAK2V,EAAAD,EAAA5C,QAAA6C,EAAA3C,KAAA2C,EAAAD,EAAA5C,OAAA,CAAjB,IAAIc,EAAI+B,EAAA5C,MACVa,EAAK,GAAKA,EAAK,GAAGlT,QAAQ,MAAO,SAEvB,IAAPkT,EAAK,KACN3T,GAAQ,uBAAyB2T,EAAK,GAAK,YAEnC,IAAPA,EAAK,KACN3T,GAAQ,QAAU2T,EAAK,GAAK,UAEpB,IAAPA,EAAK,KACN3T,GAAQ,QAAU2T,EAAK,GAAK,+GAIhC,OADA3T,GAAQ,8BAzCX2V,EAAAA,UAASZ,KAAA,CAAC,CACTC,SAAU,sDALQY,EAAAA,kBACX9D,mCAQNqD,EAAAA,qBACAA,EAAAA,sCCESC,EACAhM,GADAvI,KAAAuU,GAAAA,EACAvU,KAAAuI,IAAAA,SAEHyM,EAAA3T,UAAA6P,oBACLlR,KAAKoS,cAGA4C,EAAA3T,UAAAgR,uBACLrS,KAAKoS,cAGC4C,EAAA3T,UAAA+Q,sBACmB,iBAAdpS,KAAKoR,MAA0C,kBAAdpR,KAAKoR,OAC/CpR,KAAKoR,KAAOpR,KAAKoR,KAAKkB,YAEE,iBAAftS,KAAKqR,OAA4C,kBAAfrR,KAAKqR,QAChDrR,KAAKqR,MAAQrR,KAAKqR,MAAMiB,YAE1BtS,KAAKuU,GAAGE,cAAcC,UAAY1U,KAAK2U,WAAW3U,KAAKuI,IAAIiJ,YAAYxR,KAAKoR,KAAMpR,KAAKqR,SAIjF2D,EAAA3T,UAAAsT,oBAAWzV,GACjB,IAAIC,MACJA,EAAO,YACP,IAAiB,IAAAyV,EAAAjB,EAAAzU,GAAK2V,EAAAD,EAAA5C,QAAA6C,EAAA3C,KAAA2C,EAAAD,EAAA5C,OAAA,CAAjB,IAAIc,EAAI+B,EAAA5C,MACA,IAAPa,EAAK,KACP3T,GAAQ,uBAAyB2T,EAAK,GAAK,YAElC,IAAPA,EAAK,KACP3T,GAAQ,4BAAgC2T,EAAK,GAAK,kBAEzC,IAAPA,EAAK,KACP3T,GAAQ,4BAAgC2T,EAAK,GAAK,uHAItD,OADA3T,GAAQ,8BA5CX2V,EAAAA,UAASZ,KAAA,CAAC,CACTC,SAAU,0DALQY,EAAAA,kBACX9D,mCAONqD,EAAAA,qBACAA,EAAAA,sCCGSC,EACAhM,GADAvI,KAAAuU,GAAAA,EACAvU,KAAAuI,IAAAA,YALc,cACC,UAMlB0M,EAAA5T,UAAA6P,oBACLlR,KAAKoS,cAGA6C,EAAA5T,UAAAgR,uBACLrS,KAAKoS,cAGC6C,EAAA5T,UAAA+Q,sBACNpS,KAAKuU,GAAGE,cAAcC,UAAY1U,KAAK2U,WACrC3U,KAAKuI,IAAIgJ,kBAAkBvR,KAAKoR,KAAMpR,KAAKqR,SAIvC4D,EAAA5T,UAAAsT,oBAAWzV,GACjB,IAAIC,MACJA,EAAO,YACP,IAAiB,IAAAyV,EAAAjB,EAAAzU,GAAK2V,EAAAD,EAAA5C,QAAA6C,EAAA3C,KAAA2C,EAAAD,EAAA5C,OAAA,CAAjB,IAAIc,EAAI+B,EAAA5C,MACXa,EAAK,GAAKA,EAAK,GAAGlT,QAAQ,MAAO,SAEtB,IAAPkT,EAAK,KACP3T,GAAQ,uBAAyB2T,EAAK,GAAK,YAElC,IAAPA,EAAK,KACP3T,GAAQ,QAAU2T,EAAK,GAAK,UAEnB,IAAPA,EAAK,KACP3T,GAAQ,QAAU2T,EAAK,GAAK,+GAIhC,OADA3T,GAAQ,8BAzCX2V,EAAAA,UAASZ,KAAA,CAAC,CACTC,SAAU,gEALQY,EAAAA,kBACX9D,mCAONqD,EAAAA,qBACAA,EAAAA,sCCGSC,EACAhM,GADAvI,KAAAuU,GAAAA,EACAvU,KAAAuI,IAAAA,YALiC,cACC,UAMrC2M,EAAA7T,UAAA6P,oBACLlR,KAAKoS,cAGA8C,EAAA7T,UAAAgR,uBACLrS,KAAKoS,cAGC8C,EAAA7T,UAAA+Q,sBACDpS,KAAKoR,OACRpR,KAAKoR,KAAO,IAETpR,KAAKqR,QACRrR,KAAKqR,MAAQ,IAEU,iBAAdrR,KAAKoR,MAA0C,kBAAdpR,KAAKoR,OAC/CpR,KAAKoR,KAAOpR,KAAKoR,KAAKkB,YAEE,iBAAftS,KAAKqR,OAA4C,kBAAfrR,KAAKqR,QAChDrR,KAAKqR,MAAQrR,KAAKqR,MAAMiB,YAE1BtS,KAAKuU,GAAGE,cAAcC,UAAY1U,KAAK2U,WACrC3U,KAAKuI,IAAI+I,gBAAgBtR,KAAKoR,KAAMpR,KAAKqR,SAIrC6D,EAAA7T,UAAAsT,oBAAWzV,GACjB,IAAIC,MACJA,EAAO,YACP,IAAiB,IAAAyV,EAAAjB,EAAAzU,GAAK2V,EAAAD,EAAA5C,QAAA6C,EAAA3C,KAAA2C,EAAAD,EAAA5C,OAAA,CAAjB,IAAIc,EAAI+B,EAAA5C,MACXa,EAAK,GAAKA,EAAK,GAAGlT,QAAQ,MAAO,SAEtB,IAAPkT,EAAK,KACP3T,GAAQ,uBAAyB2T,EAAK,GAAK,YAElC,IAAPA,EAAK,KACP3T,GAAQ,QAAU2T,EAAK,GAAK,UAEnB,IAAPA,EAAK,KACP3T,GAAQ,QAAU2T,EAAK,GAAK,+GAIhC,OADA3T,GAAQ,8BArDX2V,EAAAA,UAASZ,KAAA,CAAC,CACTC,SAAU,8DALQY,EAAAA,kBACX9D,mCAONqD,EAAAA,qBACAA,EAAAA,cCTHa,EAAA,oDAWCC,EAAAA,SAAQlB,KAAA,CAAC,CACRmB,aAAc,CACZb,EACAQ,EACAC,EACAC,EACA/C,GAEFmD,QAAS,CACPC,EAAAA,cAEFC,QAAS,CACPhB,EACAQ,EACAC,EACAC,EACA/C,GAEFsD,UAAW,CACTzW,EACAiS,SA/BJ","sourcesContent":["export const enum DiffOp {\r\n  Delete = -1,\r\n  Equal = 0,\r\n  Insert = 1\r\n}\r\n\r\nexport type Diff = [DiffOp, string];\r\n\r\n/**\r\n * Class containing the diff, match and patch methods.\r\n\r\n */\r\nclass DiffMatchPatch {\r\n\r\n  constructor() {  }\r\n\r\n  // Defaults.\r\n  // Redefine these in your program to override the defaults.\r\n\r\n  // Number of seconds to map a diff before giving up (0 for infinity).\r\n  Diff_Timeout = 1.0;\r\n  // Cost of an empty edit operation in terms of edit characters.\r\n  Diff_EditCost = 4;\r\n  // At what point is no match declared (0.0 = perfection, 1.0 = very loose).\r\n  Match_Threshold = 0.5;\r\n  // How far to search for a match (0 = exact location, 1000+ = broad match).\r\n  // A match this many characters away from the expected location will add\r\n  // 1.0 to the score (0.0 is a perfect match).\r\n  Match_Distance = 1000;\r\n  // When deleting a large block of text (over ~64 characters), how close do\r\n  // the contents have to be to match the expected contents. (0.0 = perfection,\r\n  // 1.0 = very loose).  Note that Match_Threshold controls how closely the\r\n  // end points of a delete need to match.\r\n  Patch_DeleteThreshold = 0.5;\r\n  // Chunk size for context length.\r\n  Patch_Margin = 4;\r\n\r\n  // The number of bits in an int.\r\n  Match_MaxBits = 32;\r\n  /**\r\n   * The data structure representing a diff is an array of tuples:\r\n   * [[DiffOp.Delete, 'Hello'], [DiffOp.Insert, 'Goodbye'], [DiffOp.Equal, ' world.']]\r\n   * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\r\n   */\r\n\r\n  // Define some regex patterns for matching boundaries.\r\n  whitespaceRegex_ = new RegExp('/\\s/');\r\n  linebreakRegex_ = new RegExp('/[\\r\\n]/');\r\n  blanklineEndRegex_ = new RegExp('/\\n\\r?\\n$/');\r\n  blanklineStartRegex_ = new RegExp('/^\\r?\\n\\r?\\n/');\r\n\r\n  /**\r\n   * Find the differences between two texts.  Simplifies the problem by stripping\r\n   * any common prefix or suffix off the texts before diffing.\r\n   * @param  text1 Old string to be diffed.\r\n   * @param  text2 New string to be diffed.\r\n   * @param  opt_checklines Optional speedup flag. If present and false,\r\n   *     then don't run a line-level diff first to identify the changed areas.\r\n   *     Defaults to true, which does a faster, slightly less optimal diff.\r\n   * @param  opt_deadline Optional time when the diff should be complete\r\n   *     by.  Used internally for recursive calls.  Users should set DiffTimeout\r\n   *     instead.\r\n   * @return  Array of diff tuples.\r\n   */\r\n    diff_main (text1: string, text2: string, opt_checklines?: boolean, opt_deadline?: number): Array<Diff> {\r\n      // Set a deadline by which time the diff must be complete.\r\n      if (typeof opt_deadline == 'undefined') {\r\n        if (this.Diff_Timeout <= 0) {\r\n          opt_deadline = Number.MAX_VALUE;\r\n        } else {\r\n          opt_deadline = (new Date).getTime() + this.Diff_Timeout * 1000;\r\n        }\r\n      }\r\n      const deadline = opt_deadline;\r\n\r\n      // Check for null inputs.\r\n      if (text1 == null || text2 == null) {\r\n        throw new Error('Null input. (diff_main)');\r\n      }\r\n\r\n      // Check for equality (speedup).\r\n      if (text1 == text2) {\r\n        if (text1) {\r\n          return [[DiffOp.Equal, text1]];\r\n        }\r\n        return [];\r\n      }\r\n\r\n      if (typeof opt_checklines == 'undefined') {\r\n        opt_checklines = true;\r\n      }\r\n      const checklines = opt_checklines;\r\n\r\n      // Trim off common prefix (speedup).\r\n      let commonlength = this.diff_commonPrefix(text1, text2);\r\n      const commonprefix = text1.substring(0, commonlength);\r\n      text1 = text1.substring(commonlength);\r\n      text2 = text2.substring(commonlength);\r\n\r\n      // Trim off common suffix (speedup).\r\n      commonlength = this.diff_commonSuffix(text1, text2);\r\n      const commonsuffix = text1.substring(text1.length - commonlength);\r\n      text1 = text1.substring(0, text1.length - commonlength);\r\n      text2 = text2.substring(0, text2.length - commonlength);\r\n\r\n      // Compute the diff on the middle block.\r\n      const diffs = this.diff_compute_(text1, text2, checklines, deadline);\r\n\r\n      // Restore the prefix and suffix.\r\n      if (commonprefix) {\r\n        diffs.unshift([DiffOp.Equal, commonprefix]);\r\n      }\r\n      if (commonsuffix) {\r\n        diffs.push([DiffOp.Equal, commonsuffix]);\r\n      }\r\n      this.diff_cleanupMerge(diffs);\r\n      return diffs;\r\n  };\r\n\r\n\r\n  /**\r\n   * Find the differences between two texts.  Assumes that the texts do not\r\n   * have any common prefix or suffix.\r\n   * @param  text1 Old string to be diffed.\r\n   * @param  text2 New string to be diffed.\r\n   * @param  checklines Speedup flag.  If false, then don't run a\r\n   *     line-level diff first to identify the changed areas.\r\n   *     If true, then run a faster, slightly less optimal diff.\r\n   * @param  deadline Time when the diff should be complete by.\r\n   * @return  Array of diff tuples.\r\n\r\n   */\r\n    diff_compute_ (text1: string, text2: string, checklines: boolean,\r\n      deadline: number): Array<Diff> {\r\n    let diffs: Array<Diff>;\r\n\r\n    if (!text1) {\r\n      // Just add some text (speedup).\r\n      return [[DiffOp.Insert, text2]];\r\n    }\r\n\r\n    if (!text2) {\r\n      // Just delete some text (speedup).\r\n      return [[DiffOp.Delete, text1]];\r\n    }\r\n\r\n    const longtext = text1.length > text2.length ? text1 : text2;\r\n    const shorttext = text1.length > text2.length ? text2 : text1;\r\n    const i = longtext.indexOf(shorttext);\r\n    if (i != -1) {\r\n      // Shorter text is inside the longer text (speedup).\r\n      diffs = [[DiffOp.Insert, longtext.substring(0, i)],\r\n              [DiffOp.Equal, shorttext],\r\n              [DiffOp.Insert, longtext.substring(i + shorttext.length)]];\r\n      // Swap insertions for deletions if diff is reversed.\r\n      if (text1.length > text2.length) {\r\n        diffs[0][0] = diffs[2][0] = DiffOp.Delete;\r\n      }\r\n      return diffs;\r\n    }\r\n\r\n    if (shorttext.length == 1) {\r\n      // Single character string.\r\n      // After the previous speedup, the character can't be an equality.\r\n      return [[DiffOp.Delete, text1], [DiffOp.Insert, text2]];\r\n    }\r\n\r\n    // Check to see if the problem can be split in two.\r\n    const hm = this.diff_halfMatch_(text1, text2);\r\n    if (hm) {\r\n      // A half-match was found, sort out the return data.\r\n      const text1_a = hm[0];\r\n      const text1_b = hm[1];\r\n      const text2_a = hm[2];\r\n      const text2_b = hm[3];\r\n      const mid_common = hm[4];\r\n      // Send both pairs off for separate processing.\r\n      const diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);\r\n      const diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);\r\n      // Merge the results.\r\n      return diffs_a.concat([[DiffOp.Equal, mid_common]], diffs_b);\r\n    }\r\n\r\n    if (checklines && text1.length > 100 && text2.length > 100) {\r\n      return this.diff_lineMode_(text1, text2, deadline);\r\n    }\r\n\r\n    return this.diff_bisect_(text1, text2, deadline);\r\n  };\r\n\r\n\r\n  /**\r\n   * Do a quick line-level diff on both strings, then rediff the parts for\r\n   * greater accuracy.\r\n   * This speedup can produce non-minimal diffs.\r\n   * @param  text1 Old string to be diffed.\r\n   * @param  text2 New string to be diffed.\r\n   * @param  deadline Time when the diff should be complete by.\r\n   * @return  Array of diff tuples.\r\n\r\n   */\r\n    diff_lineMode_ (text1: string, text2: string, deadline: number) {\r\n    // Scan the text on a line-by-line basis first.\r\n    const a = this.diff_linesToChars_(text1, text2);\r\n    text1 = a.chars1;\r\n    text2 = a.chars2;\r\n    const linearray = a.lineArray;\r\n\r\n    const diffs = this.diff_main(text1, text2, false, deadline);\r\n\r\n    // Convert the diff back to original text.\r\n    this.diff_charsToLines_(diffs, linearray);\r\n    // Eliminate freak matches (e.g. blank lines)\r\n    this.diff_cleanupSemantic(diffs);\r\n\r\n    // Rediff any replacement blocks, this time character-by-character.\r\n    // Add a dummy entry at the end.\r\n    diffs.push([DiffOp.Equal, '']);\r\n    let pointer = 0;\r\n    let count_delete = 0;\r\n    let count_insert = 0;\r\n    let text_delete = '';\r\n    let text_insert = '';\r\n    while (pointer < diffs.length) {\r\n      switch (diffs[pointer][0]) {\r\n        case DiffOp.Insert:\r\n          count_insert++;\r\n          text_insert += diffs[pointer][1];\r\n          break;\r\n        case DiffOp.Delete:\r\n          count_delete++;\r\n          text_delete += diffs[pointer][1];\r\n          break;\r\n        case DiffOp.Equal:\r\n          // Upon reaching an equality, check for prior redundancies.\r\n          if (count_delete >= 1 && count_insert >= 1) {\r\n            // Delete the offending records and add the merged ones.\r\n            diffs.splice(pointer - count_delete - count_insert,\r\n                        count_delete + count_insert);\r\n            pointer = pointer - count_delete - count_insert;\r\n            const b = this.diff_main(text_delete, text_insert, false, deadline);\r\n            for (let j = b.length - 1; j >= 0; j--) {\r\n              diffs.splice(pointer, 0, b[j]);\r\n            }\r\n            pointer = pointer + b.length;\r\n          }\r\n          count_insert = 0;\r\n          count_delete = 0;\r\n          text_delete = '';\r\n          text_insert = '';\r\n          break;\r\n      }\r\n      pointer++;\r\n    }\r\n    diffs.pop();  // Remove the dummy entry at the end.\r\n\r\n    return diffs;\r\n  };\r\n\r\n\r\n  /**\r\n   * Find the 'middle snake' of a diff, split the problem in two\r\n   * and return the recursively constructed diff.\r\n   * See Myers 1986 paper: An O(ND) Difference Algorithm and Its constiations.\r\n   * @param  text1 Old string to be diffed.\r\n   * @param  text2 New string to be diffed.\r\n   * @param  deadline Time at which to bail if not yet complete.\r\n   * @return  Array of diff tuples.\r\n\r\n   */\r\n    diff_bisect_ (text1: string, text2: string, deadline: number): Array<Diff> {\r\n    // Cache the text lengths to prevent multiple calls.\r\n    const text1_length = text1.length;\r\n    const text2_length = text2.length;\r\n    const max_d = Math.ceil((text1_length + text2_length) / 2);\r\n    const v_offset = max_d;\r\n    const v_length = 2 * max_d;\r\n    const v1 = new Array(v_length);\r\n    const v2 = new Array(v_length);\r\n    // Setting all elements to -1 is faster in Chrome & Firefox than mixing\r\n    // integers and undefined.\r\n    for (let x = 0; x < v_length; x++) {\r\n      v1[x] = -1;\r\n      v2[x] = -1;\r\n    }\r\n    v1[v_offset + 1] = 0;\r\n    v2[v_offset + 1] = 0;\r\n    const delta = text1_length - text2_length;\r\n    // If the total number of characters is odd, then the front path will collide\r\n    // with the reverse path.\r\n    const front = (delta % 2 != 0);\r\n    // Offsets for start and end of k loop.\r\n    // Prevents mapping of space beyond the grid.\r\n    let k1start = 0;\r\n    let k1end = 0;\r\n    let k2start = 0;\r\n    let k2end = 0;\r\n    for (let d = 0; d < max_d; d++) {\r\n      // Bail out if deadline is reached.\r\n      if ((new Date()).getTime() > deadline) {\r\n        break;\r\n      }\r\n\r\n      // Walk the front path one step.\r\n      for (let k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\r\n        const k1_offset = v_offset + k1;\r\n        let x1;\r\n        if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {\r\n          x1 = v1[k1_offset + 1];\r\n        } else {\r\n          x1 = v1[k1_offset - 1] + 1;\r\n        }\r\n        let y1 = x1 - k1;\r\n        while (x1 < text1_length && y1 < text2_length &&\r\n              text1.charAt(x1) == text2.charAt(y1)) {\r\n          x1++;\r\n          y1++;\r\n        }\r\n        v1[k1_offset] = x1;\r\n        if (x1 > text1_length) {\r\n          // Ran off the right of the graph.\r\n          k1end += 2;\r\n        } else if (y1 > text2_length) {\r\n          // Ran off the bottom of the graph.\r\n          k1start += 2;\r\n        } else if (front) {\r\n          const k2_offset = v_offset + delta - k1;\r\n          if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {\r\n            // Mirror x2 onto top-left coordinate system.\r\n            const x2 = text1_length - v2[k2_offset];\r\n            if (x1 >= x2) {\r\n              // Overlap detected.\r\n              return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      // Walk the reverse path one step.\r\n      for (let k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\r\n        const k2_offset = v_offset + k2;\r\n        let x2: number;\r\n        if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {\r\n          x2 = v2[k2_offset + 1];\r\n        } else {\r\n          x2 = v2[k2_offset - 1] + 1;\r\n        }\r\n        let y2 = x2 - k2;\r\n        while (x2 < text1_length && y2 < text2_length &&\r\n              text1.charAt(text1_length - x2 - 1) ==\r\n              text2.charAt(text2_length - y2 - 1)) {\r\n          x2++;\r\n          y2++;\r\n        }\r\n        v2[k2_offset] = x2;\r\n        if (x2 > text1_length) {\r\n          // Ran off the left of the graph.\r\n          k2end += 2;\r\n        } else if (y2 > text2_length) {\r\n          // Ran off the top of the graph.\r\n          k2start += 2;\r\n        } else if (!front) {\r\n          const k1_offset = v_offset + delta - k2;\r\n          if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {\r\n            const x1 = v1[k1_offset];\r\n            const y1 = v_offset + x1 - k1_offset;\r\n            // Mirror x2 onto top-left coordinate system.\r\n            x2 = text1_length - x2;\r\n            if (x1 >= x2) {\r\n              // Overlap detected.\r\n              return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // Diff took too long and hit the deadline or\r\n    // number of diffs equals number of characters, no commonality at all.\r\n    return [[DiffOp.Delete, text1], [DiffOp.Insert, text2]];\r\n  };\r\n\r\n\r\n  /**\r\n   * Given the location of the 'middle snake', split the diff in two parts\r\n   * and recurse.\r\n   * @param  text1 Old string to be diffed.\r\n   * @param  text2 New string to be diffed.\r\n   * @param  x Index of split point in text1.\r\n   * @param  y Index of split point in text2.\r\n   * @param  deadline Time at which to bail if not yet complete.\r\n   * @return  Array of diff tuples.\r\n\r\n   */\r\n    diff_bisectSplit_ (text1: string, text2: string, x: number, y: number, deadline: number) {\r\n      const text1a = text1.substring(0, x);\r\n      const text2a = text2.substring(0, y);\r\n      const text1b = text1.substring(x);\r\n      const text2b = text2.substring(y);\r\n\r\n      // Compute both diffs serially.\r\n      const diffs = this.diff_main(text1a, text2a, false, deadline);\r\n      const diffsb = this.diff_main(text1b, text2b, false, deadline);\r\n\r\n      return diffs.concat(diffsb);\r\n    };\r\n\r\n\r\n  /**\r\n   * Split two texts into an array of strings.  Reduce the texts to a string of\r\n   * hashes where each Unicode character represents one line.\r\n   * @param  text1 First string.\r\n   * @param  text2 Second string.\r\n   * @return }\r\n   *     An object containing the encoded text1, the encoded text2 and\r\n   *     the array of unique strings.\r\n   *     The zeroth element of the array of unique strings is intentionally blank.\r\n\r\n   */\r\n    diff_linesToChars_ (text1: string, text2: string) {\r\n      const lineArray = [];  // e.g. lineArray[4] == 'Hello\\n'\r\n      const lineHash = {};   // e.g. lineHash['Hello\\n'] == 4\r\n\r\n      // '\\x00' is a valid character, but constious debuggers don't like it.\r\n      // So we'll insert a junk entry to avoid generating a null character.\r\n      lineArray[0] = '';\r\n\r\n\r\n      const chars1 = this.diff_linesToCharsMunge_(text1, lineArray, lineHash);\r\n      const chars2 = this.diff_linesToCharsMunge_(text2, lineArray, lineHash);\r\n      return {chars1: chars1, chars2: chars2, lineArray: lineArray};\r\n   };\r\n\r\n  /**\r\n   * Split a text into an array of strings.  Reduce the texts to a string of\r\n   * hashes where each Unicode character represents one line.\r\n   * Modifies linearray and linehash through being a closure.\r\n   * @param  text String to encode.\r\n   * @return  Encoded string.\r\n\r\n   */\r\n  diff_linesToCharsMunge_(text: string, lineArray: Array<string>, lineHash: any): string {\r\n    let chars = '';\r\n    // Walk the text, pulling out a substring for each line.\r\n    // text.split('\\n') would would temporarily double our memory footprint.\r\n    // Modifying text would create many large strings to garbage collect.\r\n    let lineStart = 0;\r\n    let lineEnd = -1;\r\n    // Keeping our own length constiable is faster than looking it up.\r\n    let lineArrayLength = lineArray.length;\r\n    while (lineEnd < text.length - 1) {\r\n      lineEnd = text.indexOf('\\n', lineStart);\r\n      if (lineEnd == -1) {\r\n        lineEnd = text.length - 1;\r\n      }\r\n      const line = text.substring(lineStart, lineEnd + 1);\r\n      lineStart = lineEnd + 1;\r\n\r\n      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) :\r\n          (lineHash[line] !== undefined)) {\r\n        chars += String.fromCharCode(lineHash[line]);\r\n      } else {\r\n        chars += String.fromCharCode(lineArrayLength);\r\n        lineHash[line] = lineArrayLength;\r\n        lineArray[lineArrayLength++] = line;\r\n      }\r\n    }\r\n    return chars;\r\n  }\r\n\r\n  /**\r\n   * Rehydrate the text in a diff from a string of line hashes to real lines of\r\n   * text.\r\n   * @param  diffs Array of diff tuples.\r\n   * @param  lineArray Array of unique strings.\r\n\r\n   */\r\n    diff_charsToLines_ (diffs: Array<Diff>, lineArray: Array<string>): void {\r\n    for (let x = 0; x < diffs.length; x++) {\r\n      const chars = diffs[x][1];\r\n      const text = [];\r\n      for (let y = 0; y < chars.length; y++) {\r\n        text[y] = lineArray[chars.charCodeAt(y)];\r\n      }\r\n      diffs[x][1] = text.join('');\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Determine the common prefix of two strings.\r\n   * @param  text1 First string.\r\n   * @param  text2 Second string.\r\n   * @return  The number of characters common to the start of each\r\n   *     string.\r\n   */\r\n    diff_commonPrefix (text1: string, text2: string): number {\r\n    // Quick check for common null cases.\r\n    if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {\r\n      return 0;\r\n    }\r\n    // Binary search.\r\n    // Performance analysis: http://neil.fraser.name/news/2007/10/09/\r\n    let pointermin = 0;\r\n    let pointermax = Math.min(text1.length, text2.length);\r\n    let pointermid = pointermax;\r\n    let pointerstart = 0;\r\n    while (pointermin < pointermid) {\r\n      if (text1.substring(pointerstart, pointermid) ==\r\n          text2.substring(pointerstart, pointermid)) {\r\n        pointermin = pointermid;\r\n        pointerstart = pointermin;\r\n      } else {\r\n        pointermax = pointermid;\r\n      }\r\n      pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\r\n    }\r\n    return pointermid;\r\n  };\r\n\r\n\r\n  /**\r\n   * Determine the common suffix of two strings.\r\n   * @param  text1 First string.\r\n   * @param  text2 Second string.\r\n   * @return  The number of characters common to the end of each string.\r\n   */\r\n    diff_commonSuffix (text1: string, text2: string): number {\r\n    // Quick check for common null cases.\r\n    if (!text1 || !text2 ||\r\n        text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {\r\n      return 0;\r\n    }\r\n    // Binary search.\r\n    // Performance analysis: http://neil.fraser.name/news/2007/10/09/\r\n    let pointermin = 0;\r\n    let pointermax = Math.min(text1.length, text2.length);\r\n    let pointermid = pointermax;\r\n    let pointerend = 0;\r\n    while (pointermin < pointermid) {\r\n      if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==\r\n          text2.substring(text2.length - pointermid, text2.length - pointerend)) {\r\n        pointermin = pointermid;\r\n        pointerend = pointermin;\r\n      } else {\r\n        pointermax = pointermid;\r\n      }\r\n      pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\r\n    }\r\n    return pointermid;\r\n  };\r\n\r\n\r\n  /**\r\n   * Determine if the suffix of one string is the prefix of another.\r\n   * @param  text1 First string.\r\n   * @param  text2 Second string.\r\n   * @return  The number of characters common to the end of the first\r\n   *     string and the start of the second string.\r\n\r\n   */\r\n    diff_commonOverlap_ (text1: string, text2: string): number {\r\n    // Cache the text lengths to prevent multiple calls.\r\n    const text1_length = text1.length;\r\n    const text2_length = text2.length;\r\n    // Eliminate the null case.\r\n    if (text1_length == 0 || text2_length == 0) {\r\n      return 0;\r\n    }\r\n    // Truncate the longer string.\r\n    if (text1_length > text2_length) {\r\n      text1 = text1.substring(text1_length - text2_length);\r\n    } else if (text1_length < text2_length) {\r\n      text2 = text2.substring(0, text1_length);\r\n    }\r\n    const text_length = Math.min(text1_length, text2_length);\r\n    // Quick check for the worst case.\r\n    if (text1 == text2) {\r\n      return text_length;\r\n    }\r\n\r\n    // Start by looking for a single character match\r\n    // and increase length until no match is found.\r\n    // Performance analysis: http://neil.fraser.name/news/2010/11/04/\r\n    let best = 0;\r\n    let length = 1;\r\n    while (true) {\r\n      const pattern = text1.substring(text_length - length);\r\n      const found = text2.indexOf(pattern);\r\n      if (found == -1) {\r\n        return best;\r\n      }\r\n      length += found;\r\n      if (found == 0 || text1.substring(text_length - length) ==\r\n          text2.substring(0, length)) {\r\n        best = length;\r\n        length++;\r\n      }\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Do the two texts share a substring which is at least half the length of the\r\n   * longer text?\r\n   * This speedup can produce non-minimal diffs.\r\n   * @param  text1 First string.\r\n   * @param  text2 Second string.\r\n   * @return  Five element Array, containing the prefix of\r\n   *     text1, the suffix of text1, the prefix of text2, the suffix of\r\n   *     text2 and the common middle.  Or null if there was no match.\r\n\r\n   */\r\n    diff_halfMatch_ (text1: string, text2: string) {\r\n    if (this.Diff_Timeout <= 0) {\r\n      // Don't risk returning a non-optimal diff if we have unlimited time.\r\n      return null;\r\n    }\r\n    const longtext = text1.length > text2.length ? text1 : text2;\r\n    const shorttext = text1.length > text2.length ? text2 : text1;\r\n    if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {\r\n      return null;  // Pointless.\r\n    }\r\n    const dmp = this;  // 'this' becomes 'window' in a closure.\r\n\r\n\r\n    // First check if the second quarter is the seed for a half-match.\r\n    const hm1 = this.diff_halfMatchI_(longtext, shorttext,\r\n                              Math.ceil(longtext.length / 4), dmp);\r\n    // Check again based on the third quarter.\r\n    const hm2 = this.diff_halfMatchI_(longtext, shorttext,\r\n                              Math.ceil(longtext.length / 2), dmp);\r\n    let hm;\r\n    if (!hm1 && !hm2) {\r\n      return null;\r\n    } else if (!hm2) {\r\n      hm = hm1;\r\n    } else if (!hm1) {\r\n      hm = hm2;\r\n    } else {\r\n      // Both matched.  Select the longest.\r\n      hm = hm1[4].length > hm2[4].length ? hm1 : hm2;\r\n    }\r\n\r\n    // A half-match was found, sort out the return data.\r\n    let text1_a, text1_b, text2_a, text2_b;\r\n    if (text1.length > text2.length) {\r\n      text1_a = hm[0];\r\n      text1_b = hm[1];\r\n      text2_a = hm[2];\r\n      text2_b = hm[3];\r\n    } else {\r\n      text2_a = hm[0];\r\n      text2_b = hm[1];\r\n      text1_a = hm[2];\r\n      text1_b = hm[3];\r\n    }\r\n    const mid_common = hm[4];\r\n    return [text1_a, text1_b, text2_a, text2_b, mid_common];\r\n  };\r\n\r\n  /**\r\n   * Does a substring of shorttext exist within longtext such that the substring\r\n   * is at least half the length of longtext?\r\n   * Closure, but does not reference any external constiables.\r\n   * @param  longtext Longer string.\r\n   * @param  shorttext Shorter string.\r\n   * @param  i Start index of quarter length substring within longtext.\r\n   * @return  Five element Array, containing the prefix of\r\n   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\r\n   *     of shorttext and the common middle.  Or null if there was no match.\r\n\r\n   */\r\n  diff_halfMatchI_(longtext: string, shorttext: string, i: number, dmp: DiffMatchPatch): Array<string> {\r\n    // Start with a 1/4 length substring at position i as a seed.\r\n    const seed = longtext.substring(i, i + Math.floor(longtext.length / 4));\r\n    let j = -1;\r\n    let best_common = '';\r\n    let best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;\r\n    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {\r\n      const prefixLength = dmp.diff_commonPrefix(longtext.substring(i),\r\n                                              shorttext.substring(j));\r\n      const suffixLength = dmp.diff_commonSuffix(longtext.substring(0, i),\r\n                                              shorttext.substring(0, j));\r\n      if (best_common.length < suffixLength + prefixLength) {\r\n        best_common = shorttext.substring(j - suffixLength, j) +\r\n            shorttext.substring(j, j + prefixLength);\r\n        best_longtext_a = longtext.substring(0, i - suffixLength);\r\n        best_longtext_b = longtext.substring(i + prefixLength);\r\n        best_shorttext_a = shorttext.substring(0, j - suffixLength);\r\n        best_shorttext_b = shorttext.substring(j + prefixLength);\r\n      }\r\n    }\r\n    if (best_common.length * 2 >= longtext.length) {\r\n      return [best_longtext_a, best_longtext_b,\r\n              best_shorttext_a, best_shorttext_b, best_common];\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Reduce the number of edits by eliminating semantically trivial equalities.\r\n   * @param  diffs Array of diff tuples.\r\n   */\r\n    diff_cleanupSemantic (diffs: Array<Diff>) {\r\n    let changes = false;\r\n    const equalities = [];  // Stack of indices where equalities are found.\r\n    let equalitiesLength = 0;  // Keeping our own length const is faster in JS.\r\n\r\n    let lastequality = null;\r\n    // Always equal to diffs[equalities[equalitiesLength - 1]][1]\r\n    let pointer = 0;  // Index of current position.\r\n    // Number of characters that changed prior to the equality.\r\n    let length_insertions1 = 0;\r\n    let length_deletions1 = 0;\r\n    // Number of characters that changed after the equality.\r\n    let length_insertions2 = 0;\r\n    let length_deletions2 = 0;\r\n    while (pointer < diffs.length) {\r\n      if (diffs[pointer][0] == DiffOp.Equal) {  // Equality found.\r\n        equalities[equalitiesLength++] = pointer;\r\n        length_insertions1 = length_insertions2;\r\n        length_deletions1 = length_deletions2;\r\n        length_insertions2 = 0;\r\n        length_deletions2 = 0;\r\n        lastequality = diffs[pointer][1];\r\n      } else {  // An insertion or deletion.\r\n        if (diffs[pointer][0] == DiffOp.Insert) {\r\n          length_insertions2 += diffs[pointer][1].length;\r\n        } else {\r\n          length_deletions2 += diffs[pointer][1].length;\r\n        }\r\n        // Eliminate an equality that is smaller or equal to the edits on both\r\n        // sides of it.\r\n        if (lastequality && (lastequality.length <=\r\n            Math.max(length_insertions1, length_deletions1)) &&\r\n            (lastequality.length <= Math.max(length_insertions2,\r\n                                            length_deletions2))) {\r\n          // Duplicate record.\r\n          diffs.splice(equalities[equalitiesLength - 1], 0,\r\n                      [DiffOp.Delete, lastequality]);\r\n          // Change second copy to insert.\r\n          diffs[equalities[equalitiesLength - 1] + 1][0] = DiffOp.Insert;\r\n          // Throw away the equality we just deleted.\r\n          equalitiesLength--;\r\n          // Throw away the previous equality (it needs to be reevaluated).\r\n          equalitiesLength--;\r\n          pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\r\n          length_insertions1 = 0;  // Reset the counters.\r\n          length_deletions1 = 0;\r\n          length_insertions2 = 0;\r\n          length_deletions2 = 0;\r\n          lastequality = null;\r\n          changes = true;\r\n        }\r\n      }\r\n      pointer++;\r\n    }\r\n\r\n    // Normalize the diff.\r\n    if (changes) {\r\n      this.diff_cleanupMerge(diffs);\r\n    }\r\n    this.diff_cleanupSemanticLossless(diffs);\r\n\r\n    // Find any overlaps between deletions and insertions.\r\n    // e.g: <del>abcxxx</del><ins>xxxdef</ins>\r\n    //   -> <del>abc</del>xxx<ins>def</ins>\r\n    // e.g: <del>xxxabc</del><ins>defxxx</ins>\r\n    //   -> <ins>def</ins>xxx<del>abc</del>\r\n    // Only extract an overlap if it is as big as the edit ahead or behind it.\r\n    pointer = 1;\r\n    while (pointer < diffs.length) {\r\n      if (diffs[pointer - 1][0] == DiffOp.Delete &&\r\n          diffs[pointer][0] == DiffOp.Insert) {\r\n        const deletion = diffs[pointer - 1][1];\r\n        const insertion = diffs[pointer][1];\r\n        const overlap_length1 = this.diff_commonOverlap_(deletion, insertion);\r\n        const overlap_length2 = this.diff_commonOverlap_(insertion, deletion);\r\n        if (overlap_length1 >= overlap_length2) {\r\n          if (overlap_length1 >= deletion.length / 2 ||\r\n              overlap_length1 >= insertion.length / 2) {\r\n            // Overlap found.  Insert an equality and trim the surrounding edits.\r\n            diffs.splice(pointer, 0,\r\n                [DiffOp.Equal, insertion.substring(0, overlap_length1)]);\r\n            diffs[pointer - 1][1] =\r\n                deletion.substring(0, deletion.length - overlap_length1);\r\n            diffs[pointer + 1][1] = insertion.substring(overlap_length1);\r\n            pointer++;\r\n          }\r\n        } else {\r\n          if (overlap_length2 >= deletion.length / 2 ||\r\n              overlap_length2 >= insertion.length / 2) {\r\n            // Reverse overlap found.\r\n            // Insert an equality and swap and trim the surrounding edits.\r\n            diffs.splice(pointer, 0,\r\n                [DiffOp.Equal, deletion.substring(0, overlap_length2)]);\r\n            diffs[pointer - 1][0] = DiffOp.Insert;\r\n            diffs[pointer - 1][1] =\r\n                insertion.substring(0, insertion.length - overlap_length2);\r\n            diffs[pointer + 1][0] = DiffOp.Delete;\r\n            diffs[pointer + 1][1] =\r\n                deletion.substring(overlap_length2);\r\n            pointer++;\r\n          }\r\n        }\r\n        pointer++;\r\n      }\r\n      pointer++;\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Look for single edits surrounded on both sides by equalities\r\n   * which can be shifted sideways to align the edit to a word boundary.\r\n   * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.\r\n   * @param  diffs Array of diff tuples.\r\n   */\r\n    diff_cleanupSemanticLossless (diffs: Array<Diff>) {\r\n    /**\r\n     * Given two strings, compute a score representing whether the internal\r\n     * boundary falls on logical boundaries.\r\n     * Scores range from 6 (best) to 0 (worst).\r\n     * Closure, but does not reference any external constiables.\r\n     * @param  one First string.\r\n     * @param  two Second string.\r\n     * @return  The score.\r\n\r\n     */\r\n    function diff_cleanupSemanticScore_(one: string, two: string): number {\r\n      if (!one || !two) {\r\n        // Edges are the best.\r\n        return 6;\r\n      }\r\n\r\n\r\n      const nonAlphaNumericRegex_ = new RegExp('/[^a-zA-Z0-9]/');\r\n\r\n      // Each port of this function behaves slightly differently due to\r\n      // subtle differences in each language's definition of things like\r\n      // 'whitespace'.  Since this function's purpose is largely cosmetic,\r\n      // the choice has been made to use each language's native features\r\n      // rather than force total conformity.\r\n      const char1 = one.charAt(one.length - 1);\r\n      const char2 = two.charAt(0);\r\n      const nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex_);\r\n      const nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex_);\r\n      const whitespace1 = nonAlphaNumeric1 &&\r\n          char1.match(this.whitespaceRegex_);\r\n      const whitespace2 = nonAlphaNumeric2 &&\r\n          char2.match(this.whitespaceRegex_);\r\n      const lineBreak1 = whitespace1 &&\r\n          char1.match(this.linebreakRegex_);\r\n      const lineBreak2 = whitespace2 &&\r\n          char2.match(this.linebreakRegex_);\r\n      const blankLine1 = lineBreak1 &&\r\n          one.match(this.blanklineEndRegex_);\r\n      const blankLine2 = lineBreak2 &&\r\n          two.match(this.blanklineStartRegex_);\r\n\r\n      if (blankLine1 || blankLine2) {\r\n        // Five points for blank lines.\r\n        return 5;\r\n      } else if (lineBreak1 || lineBreak2) {\r\n        // Four points for line breaks.\r\n        return 4;\r\n      } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {\r\n        // Three points for end of sentences.\r\n        return 3;\r\n      } else if (whitespace1 || whitespace2) {\r\n        // Two points for whitespace.\r\n        return 2;\r\n      } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {\r\n        // One point for non-alphanumeric.\r\n        return 1;\r\n      }\r\n      return 0;\r\n    }\r\n\r\n    let pointer = 1;\r\n    // Intentionally ignore the first and last element (don't need checking).\r\n    while (pointer < diffs.length - 1) {\r\n      if (diffs[pointer - 1][0] == DiffOp.Equal &&\r\n          diffs[pointer + 1][0] == DiffOp.Equal) {\r\n        // This is a single edit surrounded by equalities.\r\n        let equality1 = diffs[pointer - 1][1];\r\n        let edit = diffs[pointer][1];\r\n        let equality2 = diffs[pointer + 1][1];\r\n\r\n        // First, shift the edit as far left as possible.\r\n        const commonOffset = this.diff_commonSuffix(equality1, edit);\r\n        if (commonOffset) {\r\n          const commonString = edit.substring(edit.length - commonOffset);\r\n          equality1 = equality1.substring(0, equality1.length - commonOffset);\r\n          edit = commonString + edit.substring(0, edit.length - commonOffset);\r\n          equality2 = commonString + equality2;\r\n        }\r\n\r\n        // Second, step character by character right, looking for the best fit.\r\n        let bestEquality1 = equality1;\r\n        let bestEdit = edit;\r\n        let bestEquality2 = equality2;\r\n        let bestScore = diff_cleanupSemanticScore_(equality1, edit) +\r\n            diff_cleanupSemanticScore_(edit, equality2);\r\n        while (edit.charAt(0) === equality2.charAt(0)) {\r\n          equality1 += edit.charAt(0);\r\n          edit = edit.substring(1) + equality2.charAt(0);\r\n          equality2 = equality2.substring(1);\r\n          const score = diff_cleanupSemanticScore_(equality1, edit) +\r\n              diff_cleanupSemanticScore_(edit, equality2);\r\n          // The >= encourages trailing rather than leading whitespace on edits.\r\n          if (score >= bestScore) {\r\n            bestScore = score;\r\n            bestEquality1 = equality1;\r\n            bestEdit = edit;\r\n            bestEquality2 = equality2;\r\n          }\r\n        }\r\n\r\n        if (diffs[pointer - 1][1] != bestEquality1) {\r\n          // We have an improvement, save it back to the diff.\r\n          if (bestEquality1) {\r\n            diffs[pointer - 1][1] = bestEquality1;\r\n          } else {\r\n            diffs.splice(pointer - 1, 1);\r\n            pointer--;\r\n          }\r\n          diffs[pointer][1] = bestEdit;\r\n          if (bestEquality2) {\r\n            diffs[pointer + 1][1] = bestEquality2;\r\n          } else {\r\n            diffs.splice(pointer + 1, 1);\r\n            pointer--;\r\n          }\r\n        }\r\n      }\r\n      pointer++;\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Reduce the number of edits by eliminating operationally trivial equalities.\r\n   * @param  diffs Array of diff tuples.\r\n   */\r\n    diff_cleanupEfficiency (diffs: Array<Diff>) {\r\n    let changes = false;\r\n    const equalities = [];  // Stack of indices where equalities are found.\r\n    let equalitiesLength = 0;  // Keeping our own length const is faster in JS.\r\n\r\n    let lastequality = null;\r\n    // Always equal to diffs[equalities[equalitiesLength - 1]][1]\r\n    let pointer = 0;  // Index of current position.\r\n    // Is there an insertion operation before the last equality.\r\n    let pre_ins = false;\r\n    // Is there a deletion operation before the last equality.\r\n    let pre_del = false;\r\n    // Is there an insertion operation after the last equality.\r\n    let post_ins = false;\r\n    // Is there a deletion operation after the last equality.\r\n    let post_del = false;\r\n    while (pointer < diffs.length) {\r\n      if (diffs[pointer][0] == DiffOp.Equal) {  // Equality found.\r\n        if (diffs[pointer][1].length < this.Diff_EditCost &&\r\n            (post_ins || post_del)) {\r\n          // Candidate found.\r\n          equalities[equalitiesLength++] = pointer;\r\n          pre_ins = post_ins;\r\n          pre_del = post_del;\r\n          lastequality = diffs[pointer][1];\r\n        } else {\r\n          // Not a candidate, and can never become one.\r\n          equalitiesLength = 0;\r\n          lastequality = null;\r\n        }\r\n        post_ins = post_del = false;\r\n      } else {  // An insertion or deletion.\r\n        if (diffs[pointer][0] == DiffOp.Delete) {\r\n          post_del = true;\r\n        } else {\r\n          post_ins = true;\r\n        }\r\n        /*\r\n        * Five types to be split:\r\n        * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\r\n        * <ins>A</ins>X<ins>C</ins><del>D</del>\r\n        * <ins>A</ins><del>B</del>X<ins>C</ins>\r\n        * <ins>A</del>X<ins>C</ins><del>D</del>\r\n        * <ins>A</ins><del>B</del>X<del>C</del>\r\n        */\r\n        if (lastequality && ((pre_ins && pre_del && post_ins && post_del) ||\r\n                            ((lastequality.length < this.Diff_EditCost / 2) &&\r\n                            ((pre_ins?1:0) + (pre_del?1:0) + (post_ins?1:0) + (post_del?1:0) == 3)))) {\r\n          // Duplicate record.\r\n          diffs.splice(equalities[equalitiesLength - 1], 0,\r\n                      [DiffOp.Delete, lastequality]);\r\n          // Change second copy to insert.\r\n          diffs[equalities[equalitiesLength - 1] + 1][0] = DiffOp.Insert;\r\n          equalitiesLength--;  // Throw away the equality we just deleted;\r\n          lastequality = null;\r\n          if (pre_ins && pre_del) {\r\n            // No changes made which could affect previous entry, keep going.\r\n            post_ins = post_del = true;\r\n            equalitiesLength = 0;\r\n          } else {\r\n            equalitiesLength--;  // Throw away the previous equality.\r\n            pointer = equalitiesLength > 0 ?\r\n                equalities[equalitiesLength - 1] : -1;\r\n            post_ins = post_del = false;\r\n          }\r\n          changes = true;\r\n        }\r\n      }\r\n      pointer++;\r\n    }\r\n\r\n    if (changes) {\r\n      this.diff_cleanupMerge(diffs);\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Reorder and merge like edit sections.  Merge equalities.\r\n   * Any edit section can move as long as it doesn't cross an equality.\r\n   * @param  diffs Array of diff tuples.\r\n   */\r\n    diff_cleanupMerge (diffs: Array<Diff>) {\r\n    diffs.push([DiffOp.Equal, '']);  // Add a dummy entry at the end.\r\n    let pointer = 0;\r\n    let count_delete = 0;\r\n    let count_insert = 0;\r\n    let text_delete = '';\r\n    let text_insert = '';\r\n    let commonlength;\r\n    while (pointer < diffs.length) {\r\n      switch (diffs[pointer][0]) {\r\n        case DiffOp.Insert:\r\n          count_insert++;\r\n          text_insert += diffs[pointer][1];\r\n          pointer++;\r\n          break;\r\n        case DiffOp.Delete:\r\n          count_delete++;\r\n          text_delete += diffs[pointer][1];\r\n          pointer++;\r\n          break;\r\n        case DiffOp.Equal:\r\n          // Upon reaching an equality, check for prior redundancies.\r\n          if (count_delete + count_insert > 1) {\r\n            if (count_delete !== 0 && count_insert !== 0) {\r\n              // Factor out any common prefixies.\r\n              commonlength = this.diff_commonPrefix(text_insert, text_delete);\r\n              if (commonlength !== 0) {\r\n                if ((pointer - count_delete - count_insert) > 0 &&\r\n                    diffs[pointer - count_delete - count_insert - 1][0] ==\r\n                    DiffOp.Equal) {\r\n                  diffs[pointer - count_delete - count_insert - 1][1] +=\r\n                      text_insert.substring(0, commonlength);\r\n                } else {\r\n                  diffs.splice(0, 0, [DiffOp.Equal,\r\n                                      text_insert.substring(0, commonlength)]);\r\n                  pointer++;\r\n                }\r\n                text_insert = text_insert.substring(commonlength);\r\n                text_delete = text_delete.substring(commonlength);\r\n              }\r\n              // Factor out any common suffixies.\r\n              commonlength = this.diff_commonSuffix(text_insert, text_delete);\r\n              if (commonlength !== 0) {\r\n                diffs[pointer][1] = text_insert.substring(text_insert.length -\r\n                    commonlength) + diffs[pointer][1];\r\n                text_insert = text_insert.substring(0, text_insert.length -\r\n                    commonlength);\r\n                text_delete = text_delete.substring(0, text_delete.length -\r\n                    commonlength);\r\n              }\r\n            }\r\n            // Delete the offending records and add the merged ones.\r\n            if (count_delete === 0) {\r\n              diffs.splice(pointer - count_insert,\r\n                  count_delete + count_insert, [DiffOp.Insert, text_insert]);\r\n            } else if (count_insert === 0) {\r\n              diffs.splice(pointer - count_delete,\r\n                  count_delete + count_insert, [DiffOp.Delete, text_delete]);\r\n            } else {\r\n              diffs.splice(pointer - count_delete - count_insert,\r\n                  count_delete + count_insert, [DiffOp.Delete, text_delete],\r\n                  [DiffOp.Insert, text_insert]);\r\n            }\r\n            pointer = pointer - count_delete - count_insert +\r\n                      (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;\r\n          } else if (pointer !== 0 && diffs[pointer - 1][0] == DiffOp.Equal) {\r\n            // Merge this equality with the previous one.\r\n            diffs[pointer - 1][1] += diffs[pointer][1];\r\n            diffs.splice(pointer, 1);\r\n          } else {\r\n            pointer++;\r\n          }\r\n          count_insert = 0;\r\n          count_delete = 0;\r\n          text_delete = '';\r\n          text_insert = '';\r\n          break;\r\n      }\r\n    }\r\n    if (diffs[diffs.length - 1][1] === '') {\r\n      diffs.pop();  // Remove the dummy entry at the end.\r\n    }\r\n\r\n    // Second pass: look for single edits surrounded on both sides by equalities\r\n    // which can be shifted sideways to eliminate an equality.\r\n    // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\r\n    let changes = false;\r\n    pointer = 1;\r\n    // Intentionally ignore the first and last element (don't need checking).\r\n    while (pointer < diffs.length - 1) {\r\n      if (diffs[pointer - 1][0] == DiffOp.Equal &&\r\n          diffs[pointer + 1][0] == DiffOp.Equal) {\r\n        // This is a single edit surrounded by equalities.\r\n        if (diffs[pointer][1].substring(diffs[pointer][1].length -\r\n            diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {\r\n          // Shift the edit over the previous equality.\r\n          diffs[pointer][1] = diffs[pointer - 1][1] +\r\n              diffs[pointer][1].substring(0, diffs[pointer][1].length -\r\n                                          diffs[pointer - 1][1].length);\r\n          diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\r\n          diffs.splice(pointer - 1, 1);\r\n          changes = true;\r\n        } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==\r\n            diffs[pointer + 1][1]) {\r\n          // Shift the edit over the next equality.\r\n          diffs[pointer - 1][1] += diffs[pointer + 1][1];\r\n          diffs[pointer][1] =\r\n              diffs[pointer][1].substring(diffs[pointer + 1][1].length) +\r\n              diffs[pointer + 1][1];\r\n          diffs.splice(pointer + 1, 1);\r\n          changes = true;\r\n        }\r\n      }\r\n      pointer++;\r\n    }\r\n    // If shifts were made, the diff needs reordering and another shift sweep.\r\n    if (changes) {\r\n      this.diff_cleanupMerge(diffs);\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * loc is a location in text1, compute and return the equivalent location in\r\n   * text2.\r\n   * e.g. 'The cat' vs 'The big cat', 1->1, 5->8\r\n   * @param  diffs Array of diff tuples.\r\n   * @param  loc Location within text1.\r\n   * @return  Location within text2.\r\n   */\r\n    diff_xIndex (diffs: Array<Diff>, loc: number): number {\r\n    let chars1 = 0;\r\n    let chars2 = 0;\r\n    let last_chars1 = 0;\r\n    let last_chars2 = 0;\r\n    let x;\r\n    for (x = 0; x < diffs.length; x++) {\r\n      if (diffs[x][0] !== DiffOp.Insert) {  // Equality or deletion.\r\n        chars1 += diffs[x][1].length;\r\n      }\r\n      if (diffs[x][0] !== DiffOp.Delete) {  // Equality or insertion.\r\n        chars2 += diffs[x][1].length;\r\n      }\r\n      if (chars1 > loc) {  // Overshot the location.\r\n        break;\r\n      }\r\n      last_chars1 = chars1;\r\n      last_chars2 = chars2;\r\n    }\r\n    // Was the location was deleted?\r\n    if (diffs.length != x && diffs[x][0] === DiffOp.Delete) {\r\n      return last_chars2;\r\n    }\r\n    // Add the remaining character length.\r\n    return last_chars2 + (loc - last_chars1);\r\n  };\r\n\r\n\r\n  /**\r\n   * Convert a diff array into a pretty HTML report.\r\n   * @param  diffs Array of diff tuples.\r\n   * @return  HTML representation.\r\n   */\r\n    diff_prettyHtml = function(diffs: Array<Diff>): string {\r\n    const html = [];\r\n    const pattern_amp = /&/g;\r\n    const pattern_lt = /</g;\r\n    const pattern_gt = />/g;\r\n    const pattern_para = /\\n/g;\r\n    for (let x = 0; x < diffs.length; x++) {\r\n      const op = diffs[x][0];    // Operation (insert, delete, equal)\r\n      const data = diffs[x][1];  // Text of change.\r\n      const text = data.replace(pattern_amp, '&amp;').replace(pattern_lt, '&lt;')\r\n          .replace(pattern_gt, '&gt;').replace(pattern_para, '&para;<br>');\r\n      switch (op) {\r\n        case DiffOp.Insert:\r\n          html[x] = '<ins style=\"background:#e6ffe6;\">' + text + '</ins>';\r\n          break;\r\n        case DiffOp.Delete:\r\n          html[x] = '<del style=\"background:#ffe6e6;\">' + text + '</del>';\r\n          break;\r\n        case DiffOp.Equal:\r\n          html[x] = '<span>' + text + '</span>';\r\n          break;\r\n      }\r\n    }\r\n    return html.join('');\r\n  };\r\n\r\n\r\n  /**\r\n   * Compute and return the source text (all equalities and deletions).\r\n   * @param  diffs Array of diff tuples.\r\n   * @return  Source text.\r\n   */\r\n    diff_text1 (diffs: Array<Diff>): string {\r\n    const text = [];\r\n    for (let x = 0; x < diffs.length; x++) {\r\n      if (diffs[x][0] !== DiffOp.Insert) {\r\n        text[x] = diffs[x][1];\r\n      }\r\n    }\r\n    return text.join('');\r\n  };\r\n\r\n\r\n  /**\r\n   * Compute and return the destination text (all equalities and insertions).\r\n   * @param  diffs Array of diff tuples.\r\n   * @return  Destination text.\r\n   */\r\n    diff_text2 (diffs: Array<Diff>): string {\r\n    const text = [];\r\n    for (let x = 0; x < diffs.length; x++) {\r\n      if (diffs[x][0] !== DiffOp.Delete) {\r\n        text[x] = diffs[x][1];\r\n      }\r\n    }\r\n    return text.join('');\r\n  };\r\n\r\n\r\n  /**\r\n   * Compute the Levenshtein distance; the number of inserted, deleted or\r\n   * substituted characters.\r\n   * @param  diffs Array of diff tuples.\r\n   * @return  Number of changes.\r\n   */\r\n    diff_levenshtein (diffs: Array<Diff>): number {\r\n    let levenshtein = 0;\r\n    let insertions = 0;\r\n    let deletions = 0;\r\n    for (let x = 0; x < diffs.length; x++) {\r\n      const op = diffs[x][0];\r\n      const data = diffs[x][1];\r\n      switch (op) {\r\n        case DiffOp.Insert:\r\n          insertions += data.length;\r\n          break;\r\n        case DiffOp.Delete:\r\n          deletions += data.length;\r\n          break;\r\n        case DiffOp.Equal:\r\n          // A deletion and an insertion is one substitution.\r\n          levenshtein += Math.max(insertions, deletions);\r\n          insertions = 0;\r\n          deletions = 0;\r\n          break;\r\n      }\r\n    }\r\n    levenshtein += Math.max(insertions, deletions);\r\n    return levenshtein;\r\n  };\r\n\r\n\r\n  /**\r\n   * Crush the diff into an encoded string which describes the operations\r\n   * required to transform text1 into text2.\r\n   * E.g. =3\\t-2\\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.\r\n   * Operations are tab-separated.  Inserted text is escaped using %xx notation.\r\n   * @param  diffs Array of diff tuples.\r\n   * @return  Delta text.\r\n   */\r\n    diff_toDelta (diffs: Array<Diff>): string {\r\n    const text = [];\r\n    for (let x = 0; x < diffs.length; x++) {\r\n      switch (diffs[x][0]) {\r\n        case DiffOp.Insert:\r\n          text[x] = '+' + encodeURI(diffs[x][1]);\r\n          break;\r\n        case DiffOp.Delete:\r\n          text[x] = '-' + diffs[x][1].length;\r\n          break;\r\n        case DiffOp.Equal:\r\n          text[x] = '=' + diffs[x][1].length;\r\n          break;\r\n      }\r\n    }\r\n    return text.join('\\t').replace(/%20/g, ' ');\r\n  };\r\n\r\n\r\n  /**\r\n   * Given the original text1, and an encoded string which describes the\r\n   * operations required to transform text1 into text2, compute the full diff.\r\n   * @param  text1 Source string for the diff.\r\n   * @param  delta Delta text.\r\n   * @return  Array of diff tuples.\r\n   * @throws {!Error} If invalid input.\r\n   */\r\n    diff_fromDelta (text1: string, delta: string) {\r\n    const diffs = [];\r\n    let diffsLength = 0;  // Keeping our own length const is faster in JS.\r\n    let pointer = 0;  // Cursor in text1\r\n    const tokens = delta.split(/\\t/g);\r\n    for (let x = 0; x < tokens.length; x++) {\r\n      // Each token begins with a one character parameter which specifies the\r\n      // operation of this token (delete, insert, equality).\r\n      const param = tokens[x].substring(1);\r\n      switch (tokens[x].charAt(0)) {\r\n        case '+':\r\n          try {\r\n            diffs[diffsLength++] = [DiffOp.Insert, decodeURI(param)];\r\n          } catch (ex) {\r\n            // Malformed URI sequence.\r\n            throw new Error('Illegal escape in diff_fromDelta: ' + param);\r\n          }\r\n          break;\r\n        case '-':\r\n          // Fall through.\r\n        case '=':\r\n          const n = parseInt(param, 10);\r\n          if (isNaN(n) || n < 0) {\r\n            throw new Error('Invalid number in diff_fromDelta: ' + param);\r\n          }\r\n          const text = text1.substring(pointer, pointer += n);\r\n          if (tokens[x].charAt(0) == '=') {\r\n            diffs[diffsLength++] = [DiffOp.Equal, text];\r\n          } else {\r\n            diffs[diffsLength++] = [DiffOp.Delete, text];\r\n          }\r\n          break;\r\n        default:\r\n          // Blank tokens are ok (from a trailing \\t).\r\n          // Anything else is an error.\r\n          if (tokens[x]) {\r\n            throw new Error('Invalid diff operation in diff_fromDelta: ' +\r\n                            tokens[x]);\r\n          }\r\n      }\r\n    }\r\n    if (pointer != text1.length) {\r\n      throw new Error('Delta length (' + pointer +\r\n          ') does not equal source text length (' + text1.length + ').');\r\n    }\r\n    return diffs;\r\n  };\r\n\r\n  /**\r\n   * Locate the best instance of 'pattern' in 'text' near 'loc'.\r\n   * @param  text The text to search.\r\n   * @param  pattern The pattern to search for.\r\n   * @param  loc The location to search around.\r\n   * @return  Best match index or -1.\r\n   */\r\n    match_main (text: string, pattern: string, loc: number): number {\r\n    // Check for null inputs.\r\n    if (text == null || pattern == null || loc == null) {\r\n      throw new Error('Null input. (match_main)');\r\n    }\r\n\r\n    loc = Math.max(0, Math.min(loc, text.length));\r\n    if (text == pattern) {\r\n      // Shortcut (potentially not guaranteed by the algorithm)\r\n      return 0;\r\n    } else if (!text.length) {\r\n      // Nothing to match.\r\n      return -1;\r\n    } else if (text.substring(loc, loc + pattern.length) == pattern) {\r\n      // Perfect match at the perfect spot!  (Includes case of null pattern)\r\n      return loc;\r\n    } else {\r\n      // Do a fuzzy compare.\r\n      return this.match_bitap_(text, pattern, loc);\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Locate the best instance of 'pattern' in 'text' near 'loc' using the\r\n   * Bitap algorithm.\r\n   * @param  text The text to search.\r\n   * @param  pattern The pattern to search for.\r\n   * @param  loc The location to search around.\r\n   * @return  Best match index or -1.\r\n\r\n   */\r\n    match_bitap_ (text: string, pattern: string, loc: number): number {\r\n    if (pattern.length > this.Match_MaxBits) {\r\n      throw new Error('Pattern too long for this browser.');\r\n    }\r\n\r\n    // Initialise the alphabet.\r\n    const s = this.match_alphabet_(pattern);\r\n\r\n    const dmp = this;  // 'this' becomes 'window' in a closure.\r\n\r\n    /**\r\n     * Compute and return the score for a match with e errors and x location.\r\n     * Accesses loc and pattern through being a closure.\r\n     * @param  e Number of errors in match.\r\n     * @param  x Location of match.\r\n     * @return  Overall score for match (0.0 = good, 1.0 = bad).\r\n\r\n     */\r\n    function match_bitapScore_(e: number, x: number): number {\r\n      const accuracy = e / pattern.length;\r\n      const proximity = Math.abs(loc - x);\r\n      if (!dmp.Match_Distance) {\r\n        // Dodge divide by zero error.\r\n        return proximity ? 1.0 : accuracy;\r\n      }\r\n      return accuracy + (proximity / dmp.Match_Distance);\r\n    }\r\n\r\n    // Highest score beyond which we give up.\r\n    let score_threshold = this.Match_Threshold;\r\n    // Is there a nearby exact match? (speedup)\r\n    let best_loc = text.indexOf(pattern, loc);\r\n    if (best_loc != -1) {\r\n      score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);\r\n      // What about in the other direction? (speedup)\r\n      best_loc = text.lastIndexOf(pattern, loc + pattern.length);\r\n      if (best_loc != -1) {\r\n        score_threshold =\r\n            Math.min(match_bitapScore_(0, best_loc), score_threshold);\r\n      }\r\n    }\r\n\r\n    // Initialise the bit arrays.\r\n    const matchmask = 1 << (pattern.length - 1);\r\n    best_loc = -1;\r\n\r\n    let bin_min, bin_mid;\r\n    let bin_max = pattern.length + text.length;\r\n    let last_rd;\r\n    for (let d = 0; d < pattern.length; d++) {\r\n      // Scan for the best match; each iteration allows for one more error.\r\n      // Run a binary search to determine how far from 'loc' we can stray at this\r\n      // error level.\r\n      bin_min = 0;\r\n      bin_mid = bin_max;\r\n      while (bin_min < bin_mid) {\r\n        if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {\r\n          bin_min = bin_mid;\r\n        } else {\r\n          bin_max = bin_mid;\r\n        }\r\n        bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);\r\n      }\r\n      // Use the result from this iteration as the maximum for the next.\r\n      bin_max = bin_mid;\r\n      let start = Math.max(1, loc - bin_mid + 1);\r\n      const finish = Math.min(loc + bin_mid, text.length) + pattern.length;\r\n\r\n      const rd = Array(finish + 2);\r\n      rd[finish + 1] = (1 << d) - 1;\r\n      for (let j = finish; j >= start; j--) {\r\n        // The alphabet (s) is a sparse hash, so the following line generates\r\n        // warnings.\r\n        const charMatch = s[text.charAt(j - 1)];\r\n        if (d === 0) {  // First pass: exact match.\r\n          rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;\r\n        } else {  // Subsequent passes: fuzzy match.\r\n          rd[j] = (((rd[j + 1] << 1) | 1) & charMatch) |\r\n                  (((last_rd[j + 1] | last_rd[j]) << 1) | 1) |\r\n                  last_rd[j + 1];\r\n        }\r\n        if (rd[j] & matchmask) {\r\n          const score = match_bitapScore_(d, j - 1);\r\n          // This match will almost certainly be better than any existing match.\r\n          // But check anyway.\r\n          if (score <= score_threshold) {\r\n            // Told you so.\r\n            score_threshold = score;\r\n            best_loc = j - 1;\r\n            if (best_loc > loc) {\r\n              // When passing loc, don't exceed our current distance from loc.\r\n              start = Math.max(1, 2 * loc - best_loc);\r\n            } else {\r\n              // Already passed loc, downhill from here on in.\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      // No hope for a (better) match at greater error levels.\r\n      if (match_bitapScore_(d + 1, loc) > score_threshold) {\r\n        break;\r\n      }\r\n      last_rd = rd;\r\n    }\r\n    return best_loc;\r\n  };\r\n\r\n\r\n  /**\r\n   * Initialise the alphabet for the Bitap algorithm.\r\n   * @param  pattern The text to encode.\r\n   * @return  Hash of character locations.\r\n\r\n   */\r\n    match_alphabet_ (pattern: string): { [character: string]: number } {\r\n    const s: { [character: string]: number } = {};\r\n    for (let i = 0; i < pattern.length; i++) {\r\n      s[pattern.charAt(i)] = 0;\r\n    }\r\n    for (let i = 0; i < pattern.length; i++) {\r\n      s[pattern.charAt(i)] |= 1 << (pattern.length - i - 1);\r\n    }\r\n    return s;\r\n  };\r\n\r\n\r\n  /**\r\n   * Increase the context until it is unique,\r\n   * but don't let the pattern expand beyond Match_MaxBits.\r\n   * @param  patch The patch to grow.\r\n   * @param  text Source text.\r\n\r\n   */\r\n    patch_addContext_ (patch: patch_obj, text: string) {\r\n    if (text.length == 0) {\r\n      return;\r\n    }\r\n    let pattern = text.substring(patch.start2, patch.start2 + patch.length1);\r\n    let padding = 0;\r\n\r\n    // Look for the first and last matches of pattern in text.  If two different\r\n    // matches are found, increase the pattern length.\r\n    while (text.indexOf(pattern) != text.lastIndexOf(pattern) &&\r\n          pattern.length < this.Match_MaxBits - this.Patch_Margin -\r\n          this.Patch_Margin) {\r\n      padding += this.Patch_Margin;\r\n      pattern = text.substring(patch.start2 - padding,\r\n                              patch.start2 + patch.length1 + padding);\r\n    }\r\n    // Add one chunk for good luck.\r\n    padding += this.Patch_Margin;\r\n\r\n    // Add the prefix.\r\n    const prefix = text.substring(patch.start2 - padding, patch.start2);\r\n    if (prefix) {\r\n      patch.diffs.unshift([DiffOp.Equal, prefix]);\r\n    }\r\n    // Add the suffix.\r\n    const suffix = text.substring(patch.start2 + patch.length1,\r\n                                patch.start2 + patch.length1 + padding);\r\n    if (suffix) {\r\n      patch.diffs.push([DiffOp.Equal, suffix]);\r\n    }\r\n\r\n    // Roll back the start points.\r\n    patch.start1 -= prefix.length;\r\n    patch.start2 -= prefix.length;\r\n    // Extend the lengths.\r\n    patch.length1 += prefix.length + suffix.length;\r\n    patch.length2 += prefix.length + suffix.length;\r\n  };\r\n\r\n\r\n  /**\r\n   * Compute a list of patches to turn text1 into text2.\r\n   * Use diffs if provided, otherwise compute it ourselves.\r\n   * There are four ways to call this function, depending on what data is\r\n   * available to the caller:\r\n   * Method 1:\r\n   * a = text1, b = text2\r\n   * Method 2:\r\n   * a = diffs\r\n   * Method 3 (optimal):\r\n   * a = text1, b = diffs\r\n   * Method 4 (deprecated, use method 3):\r\n   * a = text1, b = text2, c = diffs\r\n   *\r\n   * @param  a text1 (methods 1,3,4) or\r\n   * Array of diff tuples for text1 to text2 (method 2).\r\n   * @param  opt_b text2 (methods 1,4) or\r\n   * Array of diff tuples for text1 to text2 (method 3) or undefined (method 2).\r\n   * @param  opt_c Array of diff tuples\r\n   * for text1 to text2 (method 4) or undefined (methods 1,2,3).\r\n   * @return  Array of Patch objects.\r\n   */\r\n    patch_make (a: string | Array<Diff>, opt_b: string | Array<Diff>, opt_c: string | Array<Diff>) {\r\n    let text1, diffs;\r\n    if (typeof a == 'string' && typeof opt_b == 'string' &&\r\n        typeof opt_c == 'undefined') {\r\n      // Method 1: text1, text2\r\n      // Compute diffs from text1 and text2.\r\n      text1 = (a);\r\n      diffs = this.diff_main(text1, (opt_b), true);\r\n      if (diffs.length > 2) {\r\n        this.diff_cleanupSemantic(diffs);\r\n        this.diff_cleanupEfficiency(diffs);\r\n      }\r\n    } else if (a && typeof a == 'object' && typeof opt_b == 'undefined' &&\r\n        typeof opt_c == 'undefined') {\r\n      // Method 2: diffs\r\n      // Compute text1 from diffs.\r\n      diffs = (a);\r\n      text1 = this.diff_text1(diffs);\r\n    } else if (typeof a == 'string' && opt_b && typeof opt_b == 'object' &&\r\n        typeof opt_c == 'undefined') {\r\n      // Method 3: text1, diffs\r\n      text1 = (a);\r\n      diffs = (opt_b);\r\n    } else if (typeof a == 'string' && typeof opt_b == 'string' &&\r\n        opt_c && typeof opt_c == 'object') {\r\n      // Method 4: text1, text2, diffs\r\n      // text2 is not used.\r\n      text1 = (a);\r\n      diffs = (opt_c);\r\n    } else {\r\n      throw new Error('Unknown call format to patch_make.');\r\n    }\r\n\r\n    if (diffs.length === 0) {\r\n      return [];  // Get rid of the null case.\r\n    }\r\n    const patches = [];\r\n    let patch = new patch_obj();\r\n    let patchDiffLength = 0;  // Keeping our own length const is faster in JS.\r\n    let char_count1 = 0;  // Number of characters into the text1 string.\r\n    let char_count2 = 0;  // Number of characters into the text2 string.\r\n    // Start with text1 (prepatch_text) and apply the diffs until we arrive at\r\n    // text2 (postpatch_text).  We recreate the patches one by one to determine\r\n    // context info.\r\n    let prepatch_text = text1;\r\n    let postpatch_text = text1;\r\n    for (let x = 0; x < diffs.length; x++) {\r\n      const diff_type = diffs[x][0];\r\n      const diff_text = diffs[x][1];\r\n\r\n      if (!patchDiffLength && diff_type !== DiffOp.Equal) {\r\n        // A new patch starts here.\r\n        patch.start1 = char_count1;\r\n        patch.start2 = char_count2;\r\n      }\r\n\r\n      switch (diff_type) {\r\n        case DiffOp.Insert:\r\n          patch.diffs[patchDiffLength++] = diffs[x];\r\n          patch.length2 += diff_text.length;\r\n          postpatch_text = postpatch_text.substring(0, char_count2) + diff_text +\r\n                          postpatch_text.substring(char_count2);\r\n          break;\r\n        case DiffOp.Delete:\r\n          patch.length1 += diff_text.length;\r\n          patch.diffs[patchDiffLength++] = diffs[x];\r\n          postpatch_text = postpatch_text.substring(0, char_count2) +\r\n                          postpatch_text.substring(char_count2 +\r\n                              diff_text.length);\r\n          break;\r\n        case DiffOp.Equal:\r\n          if (diff_text.length <= 2 * this.Patch_Margin &&\r\n              patchDiffLength && diffs.length != x + 1) {\r\n            // Small equality inside a patch.\r\n            patch.diffs[patchDiffLength++] = diffs[x];\r\n            patch.length1 += diff_text.length;\r\n            patch.length2 += diff_text.length;\r\n          } else if (diff_text.length >= 2 * this.Patch_Margin) {\r\n            // Time for a new patch.\r\n            if (patchDiffLength) {\r\n              this.patch_addContext_(patch, prepatch_text);\r\n              patches.push(patch);\r\n              patch = new patch_obj();\r\n              patchDiffLength = 0;\r\n              // Unlike Unidiff, our patch lists have a rolling context.\r\n              // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff\r\n              // Update prepatch text & pos to reflect the application of the\r\n              // just completed patch.\r\n              prepatch_text = postpatch_text;\r\n              char_count1 = char_count2;\r\n            }\r\n          }\r\n          break;\r\n      }\r\n\r\n      // Update the current character count.\r\n      if (diff_type !== DiffOp.Insert) {\r\n        char_count1 += diff_text.length;\r\n      }\r\n      if (diff_type !== DiffOp.Delete) {\r\n        char_count2 += diff_text.length;\r\n      }\r\n    }\r\n    // Pick up the leftover patch if not empty.\r\n    if (patchDiffLength) {\r\n      this.patch_addContext_(patch, prepatch_text);\r\n      patches.push(patch);\r\n    }\r\n\r\n    return patches;\r\n  };\r\n\r\n\r\n  /**\r\n   * Given an array of patches, return another array that is identical.\r\n   * @param  patches Array of Patch objects.\r\n   * @return  Array of Patch objects.\r\n   */\r\n    patch_deepCopy (patches: Array<patch_obj>): Array<patch_obj> {\r\n    // Making deep copies is hard in JavaScript.\r\n    const patchesCopy = [];\r\n    for (let x = 0; x < patches.length; x++) {\r\n      const patch = patches[x];\r\n      const patchCopy = new patch_obj();\r\n      patchCopy.diffs = [];\r\n      for (let y = 0; y < patch.diffs.length; y++) {\r\n        patchCopy.diffs[y] = [patch.diffs[y][0], patch.diffs[y][1]];\r\n      }\r\n      patchCopy.start1 = patch.start1;\r\n      patchCopy.start2 = patch.start2;\r\n      patchCopy.length1 = patch.length1;\r\n      patchCopy.length2 = patch.length2;\r\n      patchesCopy[x] = patchCopy;\r\n    }\r\n    return patchesCopy;\r\n  };\r\n\r\n\r\n  /**\r\n   * Merge a set of patches onto the text.  Return a patched text, as well\r\n   * as a list of true/false values indicating which patches were applied.\r\n   * @param  patches Array of Patch objects.\r\n   * @param  text Old text.\r\n   * @return  Two element Array, containing the\r\n   *      new text and an array of boolean values.\r\n   */\r\n    patch_apply (patches: Array<patch_obj>, text: string) {\r\n    if (patches.length == 0) {\r\n      return [text, []];\r\n    }\r\n\r\n    // Deep copy the patches so that no changes are made to originals.\r\n    patches = this.patch_deepCopy(patches);\r\n\r\n    const nullPadding = this.patch_addPadding(patches);\r\n    text = nullPadding + text + nullPadding;\r\n\r\n    this.patch_splitMax(patches);\r\n    // delta keeps track of the offset between the expected and actual location\r\n    // of the previous patch.  If there are patches expected at positions 10 and\r\n    // 20, but the first patch was found at 12, delta is 2 and the second patch\r\n    // has an effective expected position of 22.\r\n    let delta = 0;\r\n    const results = [];\r\n    for (let x = 0; x < patches.length; x++) {\r\n      const expected_loc = patches[x].start2 + delta;\r\n      const text1 = this.diff_text1(patches[x].diffs);\r\n      let start_loc;\r\n      let end_loc = -1;\r\n      if (text1.length > this.Match_MaxBits) {\r\n        // patch_splitMax will only provide an oversized pattern in the case of\r\n        // a monster delete.\r\n        start_loc = this.match_main(text, text1.substring(0, this.Match_MaxBits),\r\n                                    expected_loc);\r\n        if (start_loc != -1) {\r\n          end_loc = this.match_main(text,\r\n              text1.substring(text1.length - this.Match_MaxBits),\r\n              expected_loc + text1.length - this.Match_MaxBits);\r\n          if (end_loc == -1 || start_loc >= end_loc) {\r\n            // Can't find valid trailing context.  Drop this patch.\r\n            start_loc = -1;\r\n          }\r\n        }\r\n      } else {\r\n        start_loc = this.match_main(text, text1, expected_loc);\r\n      }\r\n      if (start_loc == -1) {\r\n        // No match found.  :(\r\n        results[x] = false;\r\n        // Subtract the delta for this failed patch from subsequent patches.\r\n        delta -= patches[x].length2 - patches[x].length1;\r\n      } else {\r\n        // Found a match.  :)\r\n        results[x] = true;\r\n        delta = start_loc - expected_loc;\r\n        let text2;\r\n        if (end_loc == -1) {\r\n          text2 = text.substring(start_loc, start_loc + text1.length);\r\n        } else {\r\n          text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);\r\n        }\r\n        if (text1 == text2) {\r\n          // Perfect match, just shove the replacement text in.\r\n          text = text.substring(0, start_loc) +\r\n                this.diff_text2(patches[x].diffs) +\r\n                text.substring(start_loc + text1.length);\r\n        } else {\r\n          // Imperfect match.  Run a diff to get a framework of equivalent\r\n          // indices.\r\n          const diffs = this.diff_main(text1, text2, false);\r\n          if (text1.length > this.Match_MaxBits &&\r\n              this.diff_levenshtein(diffs) / text1.length >\r\n              this.Patch_DeleteThreshold) {\r\n            // The end points match, but the content is unacceptably bad.\r\n            results[x] = false;\r\n          } else {\r\n            this.diff_cleanupSemanticLossless(diffs);\r\n            let index1 = 0;\r\n            let index2;\r\n            for (let y = 0; y < patches[x].diffs.length; y++) {\r\n              const mod = patches[x].diffs[y];\r\n              if (mod[0] !== DiffOp.Equal) {\r\n                index2 = this.diff_xIndex(diffs, index1);\r\n              }\r\n              if (mod[0] === DiffOp.Insert) {  // Insertion\r\n                text = text.substring(0, start_loc + index2) + mod[1] +\r\n                      text.substring(start_loc + index2);\r\n              } else if (mod[0] === DiffOp.Delete) {  // Deletion\r\n                text = text.substring(0, start_loc + index2) +\r\n                      text.substring(start_loc + this.diff_xIndex(diffs,\r\n                          index1 + mod[1].length));\r\n              }\r\n              if (mod[0] !== DiffOp.Delete) {\r\n                index1 += mod[1].length;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // Strip the padding off.\r\n    text = text.substring(nullPadding.length, text.length - nullPadding.length);\r\n    return [text, results];\r\n  };\r\n\r\n\r\n  /**\r\n   * Add some padding on text start and end so that edges can match something.\r\n   * Intended to be called only from within patch_apply.\r\n   * @param  patches Array of Patch objects.\r\n   * @return  The padding string added to each side.\r\n   */\r\n    patch_addPadding (patches: Array<patch_obj>) {\r\n    const paddingLength = this.Patch_Margin;\r\n    let nullPadding = '';\r\n    for (let x = 1; x <= paddingLength; x++) {\r\n      nullPadding += String.fromCharCode(x);\r\n    }\r\n\r\n    // Bump all the patches forward.\r\n    for (let x = 0; x < patches.length; x++) {\r\n      patches[x].start1 += paddingLength;\r\n      patches[x].start2 += paddingLength;\r\n    }\r\n\r\n    // Add some padding on start of first diff.\r\n    let patch = patches[0];\r\n    let diffs = patch.diffs;\r\n    if (diffs.length == 0 || diffs[0][0] != DiffOp.Equal) {\r\n      // Add nullPadding equality.\r\n      diffs.unshift([DiffOp.Equal, nullPadding]);\r\n      patch.start1 -= paddingLength;  // Should be 0.\r\n      patch.start2 -= paddingLength;  // Should be 0.\r\n      patch.length1 += paddingLength;\r\n      patch.length2 += paddingLength;\r\n    } else if (paddingLength > diffs[0][1].length) {\r\n      // Grow first equality.\r\n      const extraLength = paddingLength - diffs[0][1].length;\r\n      diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];\r\n      patch.start1 -= extraLength;\r\n      patch.start2 -= extraLength;\r\n      patch.length1 += extraLength;\r\n      patch.length2 += extraLength;\r\n    }\r\n\r\n    // Add some padding on end of last diff.\r\n    patch = patches[patches.length - 1];\r\n    diffs = patch.diffs;\r\n    if (diffs.length == 0 || diffs[diffs.length - 1][0] != DiffOp.Equal) {\r\n      // Add nullPadding equality.\r\n      diffs.push([DiffOp.Equal, nullPadding]);\r\n      patch.length1 += paddingLength;\r\n      patch.length2 += paddingLength;\r\n    } else if (paddingLength > diffs[diffs.length - 1][1].length) {\r\n      // Grow last equality.\r\n      const extraLength = paddingLength - diffs[diffs.length - 1][1].length;\r\n      diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);\r\n      patch.length1 += extraLength;\r\n      patch.length2 += extraLength;\r\n    }\r\n\r\n    return nullPadding;\r\n  };\r\n\r\n\r\n  /**\r\n   * Look through the patches and break up any which are longer than the maximum\r\n   * limit of the match algorithm.\r\n   * Intended to be called only from within patch_apply.\r\n   * @param  patches Array of Patch objects.\r\n   */\r\n    patch_splitMax = function(patches: Array<patch_obj>) {\r\n    const patch_size = this.Match_MaxBits;\r\n    for (let x = 0; x < patches.length; x++) {\r\n      if (patches[x].length1 <= patch_size) {\r\n        continue;\r\n      }\r\n      const bigpatch = patches[x];\r\n      // Remove the big old patch.\r\n      patches.splice(x--, 1);\r\n      let start1 = bigpatch.start1;\r\n      let start2 = bigpatch.start2;\r\n      let precontext = '';\r\n      while (bigpatch.diffs.length !== 0) {\r\n        // Create one of several smaller patches.\r\n        const patch = new patch_obj();\r\n        let empty = true;\r\n        patch.start1 = start1 - precontext.length;\r\n        patch.start2 = start2 - precontext.length;\r\n        if (precontext !== '') {\r\n          patch.length1 = patch.length2 = precontext.length;\r\n          patch.diffs.push([DiffOp.Equal, precontext]);\r\n        }\r\n        while (bigpatch.diffs.length !== 0 &&\r\n              patch.length1 < patch_size - this.Patch_Margin) {\r\n          const diff_type = bigpatch.diffs[0][0];\r\n          let diff_text = bigpatch.diffs[0][1];\r\n          if (diff_type === DiffOp.Insert) {\r\n            // Insertions are harmless.\r\n            patch.length2 += diff_text.length;\r\n            start2 += diff_text.length;\r\n            patch.diffs.push(bigpatch.diffs.shift());\r\n            empty = false;\r\n          } else if (diff_type === DiffOp.Delete && patch.diffs.length == 1 &&\r\n                    patch.diffs[0][0] == DiffOp.Equal &&\r\n                    diff_text.length > 2 * patch_size) {\r\n            // This is a large deletion.  Let it pass in one chunk.\r\n            patch.length1 += diff_text.length;\r\n            start1 += diff_text.length;\r\n            empty = false;\r\n            patch.diffs.push([diff_type, diff_text]);\r\n            bigpatch.diffs.shift();\r\n          } else {\r\n            // Deletion or equality.  Only take as much as we can stomach.\r\n            diff_text = diff_text.substring(0,\r\n                patch_size - patch.length1 - this.Patch_Margin);\r\n            patch.length1 += diff_text.length;\r\n            start1 += diff_text.length;\r\n            if (diff_type === DiffOp.Equal) {\r\n              patch.length2 += diff_text.length;\r\n              start2 += diff_text.length;\r\n            } else {\r\n              empty = false;\r\n            }\r\n            patch.diffs.push([diff_type, diff_text]);\r\n            if (diff_text == bigpatch.diffs[0][1]) {\r\n              bigpatch.diffs.shift();\r\n            } else {\r\n              bigpatch.diffs[0][1] =\r\n                  bigpatch.diffs[0][1].substring(diff_text.length);\r\n            }\r\n          }\r\n        }\r\n        // Compute the head context for the next patch.\r\n        precontext = this.diff_text2(patch.diffs);\r\n        precontext =\r\n            precontext.substring(precontext.length - this.Patch_Margin);\r\n        // Append the end context for this patch.\r\n        const postcontext = this.diff_text1(bigpatch.diffs)\r\n                              .substring(0, this.Patch_Margin);\r\n        if (postcontext !== '') {\r\n          patch.length1 += postcontext.length;\r\n          patch.length2 += postcontext.length;\r\n          if (patch.diffs.length !== 0 &&\r\n              patch.diffs[patch.diffs.length - 1][0] === DiffOp.Equal) {\r\n            patch.diffs[patch.diffs.length - 1][1] += postcontext;\r\n          } else {\r\n            patch.diffs.push([DiffOp.Equal, postcontext]);\r\n          }\r\n        }\r\n        if (!empty) {\r\n          patches.splice(++x, 0, patch);\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * Take a list of patches and return a textual representation.\r\n   * @param  patches Array of Patch objects.\r\n   * @return  Text representation of patches.\r\n   */\r\n    patch_toText (patches: Array<patch_obj>) {\r\n    const text = [];\r\n    for (let x = 0; x < patches.length; x++) {\r\n      text[x] = patches[x];\r\n    }\r\n    return text.join('');\r\n  };\r\n\r\n\r\n  /**\r\n   * Parse a textual representation of patches and return a list of Patch objects.\r\n   * @param  textline Text representation of patches.\r\n   * @return  Array of Patch objects.\r\n   * @throws {!Error} If invalid input.\r\n   */\r\n    patch_fromText (textline: string): Array<patch_obj> {\r\n    const patches: Array<patch_obj> = [];\r\n    if (!textline) {\r\n      return patches;\r\n    }\r\n    const text = textline.split('\\n');\r\n    let textPointer = 0;\r\n    const patchHeader = /^@@ -(\\d+),?(\\d*) \\+(\\d+),?(\\d*) @@$/;\r\n    while (textPointer < text.length) {\r\n      const m = text[textPointer].match(patchHeader);\r\n      if (!m) {\r\n        throw new Error('Invalid patch string: ' + text[textPointer]);\r\n      }\r\n      const patch = new patch_obj();\r\n      patches.push(patch);\r\n      patch.start1 = parseInt(m[1], 10);\r\n      if (m[2] === '') {\r\n        patch.start1--;\r\n        patch.length1 = 1;\r\n      } else if (m[2] == '0') {\r\n        patch.length1 = 0;\r\n      } else {\r\n        patch.start1--;\r\n        patch.length1 = parseInt(m[2], 10);\r\n      }\r\n\r\n      patch.start2 = parseInt(m[3], 10);\r\n      if (m[4] === '') {\r\n        patch.start2--;\r\n        patch.length2 = 1;\r\n      } else if (m[4] == '0') {\r\n        patch.length2 = 0;\r\n      } else {\r\n        patch.start2--;\r\n        patch.length2 = parseInt(m[4], 10);\r\n      }\r\n      textPointer++;\r\n\r\n      while (textPointer < text.length) {\r\n        const sign = text[textPointer].charAt(0);\r\n        let line: string;\r\n        try {\r\n          line = decodeURI(text[textPointer].substring(1));\r\n        } catch (ex) {\r\n          // Malformed URI sequence.\r\n          throw new Error('Illegal escape in patch_fromText: ' + line);\r\n        }\r\n        if (sign == '-') {\r\n          // Deletion.\r\n          patch.diffs.push([DiffOp.Delete, line]);\r\n        } else if (sign == '+') {\r\n          // Insertion.\r\n          patch.diffs.push([DiffOp.Insert, line]);\r\n        } else if (sign == ' ') {\r\n          // Minor equality.\r\n          patch.diffs.push([DiffOp.Equal, line]);\r\n        } else if (sign == '@') {\r\n          // Start of next patch.\r\n          break;\r\n        } else if (sign === '') {\r\n          // Blank line?  Whatever.\r\n        } else {\r\n          // WTF?\r\n          throw new Error('Invalid patch mode \"' + sign + '\" in: ' + line);\r\n        }\r\n        textPointer++;\r\n      }\r\n    }\r\n    return patches;\r\n  };\r\n\r\n}\r\n\r\n\r\n/**\r\n * Class representing one patch operation.\r\n\r\n */\r\nexport class patch_obj {\r\n\r\n  constructor() {  }\r\n\r\n  diffs: Array<Diff> = [];\r\n  start1: number = null;\r\n  start2: number = null;\r\n  length1: number = 0;\r\n  length2: number = 0;\r\n\r\n  /**\r\n   * Emmulate GNU diff's format.\r\n   * Header: @@ -382,8 +481,9 @@\r\n   * Indicies are printed as 1-based, not 0-based.\r\n   */\r\n  toString = function() {\r\n    let coords1, coords2;\r\n    if (this.length1 === 0) {\r\n      coords1 = this.start1 + ',0';\r\n    } else if (this.length1 == 1) {\r\n      coords1 = this.start1 + 1;\r\n    } else {\r\n      coords1 = (this.start1 + 1) + ',' + this.length1;\r\n    }\r\n    if (this.length2 === 0) {\r\n      coords2 = this.start2 + ',0';\r\n    } else if (this.length2 == 1) {\r\n      coords2 = this.start2 + 1;\r\n    } else {\r\n      coords2 = (this.start2 + 1) + ',' + this.length2;\r\n    }\r\n    const text = ['@@ -' + coords1 + ' +' + coords2 + ' @@\\n'];\r\n    let op;\r\n    // Escape the body of the patch with %xx notation.\r\n    for (let x = 0; x < this.diffs.length; x++) {\r\n      switch (this.diffs[x][0]) {\r\n        case DiffOp.Insert:\r\n          op = '+';\r\n          break;\r\n        case DiffOp.Delete:\r\n          op = '-';\r\n          break;\r\n        case DiffOp.Equal:\r\n          op = ' ';\r\n          break;\r\n      }\r\n      text[x + 1] = op + encodeURI(this.diffs[x][1]) + '\\n';\r\n    }\r\n    return text.join('').replace(/%20/g, ' ');\r\n  }\r\n}\r\n\r\nexport { DiffMatchPatch };\r\n","import { Injectable, OnInit } from '@angular/core';\r\nimport { DiffMatchPatch, DiffOp } from './diffMatchPatch';\r\n\r\n@Injectable()\r\nexport class DiffMatchPatchService implements OnInit {\r\n\r\n  constructor(private dmp: DiffMatchPatch) {   }\r\n\r\n  ngOnInit () {\r\n\r\n  }\r\n\r\n  getDiff(left: string, right: string) {\r\n     return this.dmp.diff_main(left, right);\r\n  }\r\n\r\n  getSemanticDiff(left: string, right: string) {\r\n    const diffs = this.dmp.diff_main(left, right);\r\n    this.dmp.diff_cleanupSemantic(diffs);\r\n    return diffs;\r\n  }\r\n\r\n  getProcessingDiff(left: string, right: string) {\r\n    const diffs = this.dmp.diff_main(left, right);\r\n    this.dmp.diff_cleanupEfficiency(diffs);\r\n    return diffs;\r\n  }\r\n\r\n  getLineDiff(left: string, right: string) {\r\n    const chars = this.dmp.diff_linesToChars_(left, right);\r\n    const diffs = this.dmp.diff_main(chars.chars1, chars.chars2, false);\r\n    this.dmp.diff_charsToLines_(diffs, chars.lineArray);\r\n    return diffs;\r\n  }\r\n\r\n  getDmp() {\r\n    return this.dmp;\r\n  }\r\n\r\n}\r\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import { Component, Input, OnInit, OnChanges } from '@angular/core';\r\nimport { Diff, DiffOp } from './diffMatchPatch';\r\nimport { DiffMatchPatchService } from './diffMatchPatch.service';\r\n\r\n/* Holds the state of the calculation of the diff result we intend to display.\r\n *  > lines contains the data that will be displayed on screen.\r\n *  > lineLeft keeps track of the document line number in the [left] input.\r\n *  > lineRight keeps track of the document line number in the [right] input.\r\n */\r\ntype DiffCalculation = {\r\n  lines: Array<[string, string, string, string]>,\r\n  lineLeft: number,\r\n  lineRight: number\r\n};\r\n\r\n@Component({\r\n  selector: 'dmp-line-compare',\r\n  styles: [`\r\n    div.dmp-line-compare {\r\n      display: flex;\r\n      flex-direction: row;\r\n      border: 1px solid #808080;\r\n      font-family: Consolas, Courier, monospace;\r\n      width: 911px;\r\n    }\r\n    div.dmp-line-compare-margin {\r\n      width: 101px;\r\n    }\r\n    div.dmp-line-compare-content {\r\n      position: relative;\r\n      top: 0px;\r\n      left: 0px;\r\n      flex-grow: 1;\r\n      overflow-x: scroll;\r\n    }\r\n    div.dmp-line-compare-content-wrapper {\r\n      position: absolute;\r\n      top: 0px;\r\n      left: 0px;\r\n      display: flex;\r\n      flex-direction: column;\r\n      align-items: stretch;\r\n    }\r\n    div.dmp-line-compare-left {\r\n      width: 50px;\r\n      text-align: center;\r\n      color: #484848;\r\n    }\r\n    div.dmp-line-compare-equal>div.dmp-line-compare-left,\r\n      div.dmp-line-compare-equal>div.dmp-line-compare-right {\r\n      background-color: #dedede;\r\n    }\r\n    div.dmp-line-compare-insert>div.dmp-line-compare-left,\r\n      div.dmp-line-compare-insert>div.dmp-line-compare-right {\r\n      background-color: #8bfb6f;\r\n    }\r\n    div.dmp-line-compare-delete>div.dmp-line-compare-left,\r\n      div.dmp-line-compare-delete>div.dmp-line-compare-right {\r\n      background-color: #f56868;\r\n    }\r\n    div.dmp-line-compare-right {\r\n      width: 50px;\r\n      text-align: center;\r\n      color: #484848;\r\n      border-right: 1px solid #888888;\r\n    }\r\n    div.dmp-line-compare-text {\r\n      white-space: pre;\r\n      padding-left: 10px;\r\n      min-width: 800px;\r\n    }\r\n    .dmp-line-compare-delete {\r\n      background-color: #ff8c8c;\r\n    }\r\n    .dmp-line-compare-insert {\r\n      background-color: #9dff97;\r\n    }\r\n    .dmp-line-compare-delete>div {\r\n      display: inline-block;\r\n    }  \r\n    .dmp-line-compare-insert>div {\r\n      display: inline-block;\r\n    }\r\n    .dmp-line-compare-equal>div {\r\n      display: inline-block;\r\n    }\r\n    .dmp-margin-bottom-spacer {\r\n      height: 20px;\r\n      background-color: #dedede;\r\n      border-right: 1px solid #888888;\r\n    }\r\n  `],\r\n  template: `\r\n    <div class=\"dmp-line-compare-no-changes-text\" *ngIf=\"isContentEqual\">\r\n      There are no changes to display.\r\n    </div>    \r\n    <div class=\"dmp-line-compare\" *ngIf=\"!isContentEqual\">\r\n      <div class=\"dmp-line-compare-margin\">\r\n        <div [ngClass]=\"lineDiff[0]\" *ngFor=\"let lineDiff of calculatedDiff\">\r\n          <div class=\"dmp-line-compare-left\">{{lineDiff[1]}}</div><!-- No space\r\n        --><div class=\"dmp-line-compare-right\">{{lineDiff[2]}}</div>\r\n        </div>\r\n        <div class=\"dmp-margin-bottom-spacer\"></div>\r\n      </div><!-- No space\r\n   --><div class=\"dmp-line-compare-content\">\r\n        <div class=\"dmp-line-compare-content-wrapper\">\r\n          <div [ngClass]=\"lineDiff[0]\" *ngFor=\"let lineDiff of calculatedDiff\">\r\n            <div class=\"dmp-line-compare-text\">{{lineDiff[3]}}</div>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  `\r\n})\r\nexport class LineCompareComponent implements OnInit, OnChanges {\r\n  @Input()\r\n  public left: string | number | boolean = '';\r\n  @Input()\r\n  public right: string | number | boolean = '';\r\n  // The number of lines of context to provide either side of a DiffOp.Insert or DiffOp.Delete diff.\r\n  // Context is taken from a DiffOp.Equal section.\r\n  @Input()\r\n  public lineContextSize: number;\r\n\r\n  public calculatedDiff: Array<[string, string, string, string]>;\r\n  public isContentEqual: boolean;\r\n\r\n  public constructor(\r\n      private dmp: DiffMatchPatchService) {}\r\n\r\n  public ngOnInit(): void {\r\n    this.updateHtml();\r\n  }\r\n\r\n  public ngOnChanges(): void {\r\n    this.updateHtml();\r\n  }\r\n\r\n  private updateHtml(): void {\r\n    if (typeof this.left === 'number' || typeof this.left === 'boolean') {\r\n      this.left = this.left.toString();\r\n    }\r\n    if (typeof this.right === 'number' || typeof this.right === 'boolean') {\r\n      this.right = this.right.toString();\r\n    }\r\n    this.calculateLineDiff(this.dmp.getLineDiff(this.left, this.right));\r\n  }\r\n\r\n  private calculateLineDiff(diffs: Array<Diff>): void {\r\n    const diffCalculation: DiffCalculation = {\r\n      lines: [],\r\n      lineLeft: 1,\r\n      lineRight: 1\r\n    };\r\n\r\n    this.isContentEqual = diffs.length === 1 && diffs[0][0] === DiffOp.Equal;\r\n    if (this.isContentEqual) {\r\n      this.calculatedDiff = [];\r\n      return;\r\n    }\r\n\r\n    for (let i = 0; i < diffs.length; i++) {\r\n      const diff = diffs[i];\r\n      let diffLines: string[] = diff[1].split(/\\r?\\n/);\r\n\r\n      // If the original line had a \\r\\n at the end then remove the\r\n      // empty string after it.\r\n      if (diffLines[diffLines.length - 1].length == 0) {\r\n        diffLines.pop();\r\n      }\r\n\r\n      switch (diff[0]) {\r\n        case DiffOp.Equal: {\r\n          const isFirstDiff = i === 0;\r\n          const isLastDiff = i === diffs.length - 1;\r\n          this.outputEqualDiff(diffLines, diffCalculation, isFirstDiff, isLastDiff);\r\n          break;\r\n        }\r\n        case DiffOp.Delete: {\r\n          this.outputDeleteDiff(diffLines, diffCalculation);\r\n          break;\r\n        }\r\n        case DiffOp.Insert: {\r\n          this.outputInsertDiff(diffLines, diffCalculation);\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    this.calculatedDiff = diffCalculation.lines;\r\n  }\r\n\r\n  /* If the number of diffLines is greater than lineContextSize then we may need to adjust the diff\r\n   * that is output.\r\n   *   > If the first diff of a document is DiffOp.Equal then the leading lines can be dropped\r\n   *     leaving the last 'lineContextSize' lines for context.\r\n   *   > If the last diff of a document is DiffOp.Equal then the trailing lines can be dropped\r\n   *     leaving the first 'lineContextSize' lines for context.\r\n   *   > If the diff is a DiffOp.Equal occurs in the middle then the diffs either side of it must be\r\n   *     DiffOp.Insert or DiffOp.Delete. If it has more than 2 * 'lineContextSize' lines of content\r\n   *     then the middle lines are dropped leaving the first 'lineContextSize' and last 'lineContextSize'\r\n   *     lines for context. A special line is inserted with '...' indicating that content is skipped.\r\n   *\r\n   * A document cannot consist of a single Diff with DiffOp.Equal and reach this function because\r\n   * in this case the calculateLineDiff method returns early.\r\n   */\r\n  private outputEqualDiff(\r\n      diffLines: string[],\r\n      diffCalculation: DiffCalculation,\r\n      isFirstDiff: boolean,\r\n      isLastDiff: boolean): void {\r\n    if (this.lineContextSize && diffLines.length > this.lineContextSize) {\r\n      if (isFirstDiff) {\r\n        // Take the last 'lineContextSize' lines from the first diff\r\n        const lineIncrement = diffLines.length - this.lineContextSize;\r\n        diffCalculation.lineLeft += lineIncrement;\r\n        diffCalculation.lineRight += lineIncrement;\r\n        diffLines = diffLines.slice(diffLines.length - this.lineContextSize, diffLines.length);\r\n      }\r\n      else if (isLastDiff) {\r\n        // Take only the first 'lineContextSize' lines from the final diff\r\n        diffLines = diffLines.slice(0, this.lineContextSize);\r\n      }\r\n      else if (diffLines.length > 2 * this.lineContextSize) {\r\n        // Take the first 'lineContextSize' lines from this diff to provide context for the last diff\r\n        this.outputEqualDiffLines(diffLines.slice(0, this.lineContextSize), diffCalculation);\r\n\r\n        // Output a special line indicating that some content is equal and has been skipped\r\n        diffCalculation.lines.push(['dmp-line-compare-equal', '...', '...', '...']);\r\n        const numberOfSkippedLines = diffLines.length - (2 * this.lineContextSize);\r\n        diffCalculation.lineLeft += numberOfSkippedLines;\r\n        diffCalculation.lineRight += numberOfSkippedLines;\r\n\r\n        // Take the last 'lineContextSize' lines from this diff to provide context for the next diff\r\n        this.outputEqualDiffLines(diffLines.slice(diffLines.length - this.lineContextSize), diffCalculation);\r\n        // This if branch has already output the diff lines so we return early to avoid outputting the lines\r\n        // at the end of the method.\r\n        return;\r\n      }\r\n    }\r\n    this.outputEqualDiffLines(diffLines, diffCalculation);\r\n  }\r\n\r\n  private outputEqualDiffLines(\r\n      diffLines: string[],\r\n      diffCalculation: DiffCalculation): void {\r\n    for (const line of diffLines) {\r\n      diffCalculation.lines.push(['dmp-line-compare-equal', `${diffCalculation.lineLeft}`, `${diffCalculation.lineRight}`, line]);\r\n      diffCalculation.lineLeft++;\r\n      diffCalculation.lineRight++;\r\n    }\r\n  }\r\n\r\n  private outputDeleteDiff(\r\n      diffLines: string[],\r\n      diffCalculation: DiffCalculation): void {\r\n    for (const line of diffLines) {\r\n      diffCalculation.lines.push(['dmp-line-compare-delete', `${diffCalculation.lineLeft}`, '-', line]);\r\n      diffCalculation.lineLeft++;\r\n    }\r\n  }\r\n\r\n  private outputInsertDiff(\r\n      diffLines: string[],\r\n      diffCalculation: DiffCalculation): void {\r\n    for (const line of diffLines) {\r\n      diffCalculation.lines.push(['dmp-line-compare-insert', '-', `${diffCalculation.lineRight}`, line]);\r\n      diffCalculation.lineRight++;\r\n    }\r\n  }\r\n}\r\n","import { Directive, ElementRef, Input, OnInit, OnChanges } from '@angular/core';\r\nimport { DiffMatchPatchService } from './diffMatchPatch.service';\r\nimport { Diff, DiffOp } from './diffMatchPatch';\r\n\r\n@Directive({\r\n  selector: '[diff]'\r\n})\r\nexport class DiffDirective implements OnInit, OnChanges {\r\n\r\n  @Input() left: string = '';\r\n  @Input() right: string = '';\r\n\r\n  public constructor(\r\n    private el: ElementRef,\r\n    private dmp: DiffMatchPatchService) {  }\r\n\r\n  public ngOnInit(): void {\r\n    this.updateHtml();\r\n  }\r\n\r\n  public ngOnChanges(): void {\r\n    this.updateHtml();\r\n  }\r\n\r\n  private updateHtml(): void {\r\n    this.el.nativeElement.innerHTML = this.createHtml(\r\n      this.dmp.getDiff(this.left, this.right));\r\n  }\r\n  \r\n  private createHtml(diffs: Array<Diff>): string {\r\n    let html: string;\r\n    html = '<div>';\r\n    for(let diff of diffs) {\r\n      diff[1] = diff[1].replace(/\\n/g, '<br/>');\r\n\r\n      if(diff[0] === DiffOp.Equal) {\r\n        html += '<span class=\"equal\">' + diff[1] + '</span>';\r\n      }\r\n      if(diff[0] === DiffOp.Delete) {\r\n        html += '<del>' + diff[1] + '</del>';\r\n      }\r\n      if(diff[0] === DiffOp.Insert) {\r\n        html += '<ins>' + diff[1] + '</ins>';\r\n      }\r\n    }\r\n    html += '</div>';\r\n    return html;\r\n  }\r\n}\r\n","import { Directive, ElementRef, Input, OnInit, OnChanges } from '@angular/core';\r\nimport { DiffMatchPatchService } from './diffMatchPatch.service';\r\nimport { Diff, DiffOp } from './diffMatchPatch';\r\n\r\n@Directive({\r\n  selector: '[lineDiff]',\r\n})\r\nexport class LineDiffDirective implements OnInit, OnChanges {\r\n  @Input() left: string | number | boolean;\r\n  @Input() right: string | number | boolean;\r\n\r\n  public constructor(\r\n    private el: ElementRef,\r\n    private dmp: DiffMatchPatchService) {  }\r\n\r\n  public ngOnInit(): void {\r\n    this.updateHtml();\r\n  }\r\n\r\n  public ngOnChanges(): void {\r\n    this.updateHtml();\r\n  }\r\n\r\n  private updateHtml(): void {\r\n    if (typeof this.left === 'number' || typeof this.left === 'boolean') {\r\n      this.left = this.left.toString();\r\n    }\r\n    if (typeof this.right === 'number' || typeof this.right === 'boolean') {\r\n      this.right = this.right.toString();\r\n    }\r\n    this.el.nativeElement.innerHTML = this.createHtml(this.dmp.getLineDiff(this.left, this.right));\r\n  }\r\n\r\n  // TODO: Need to fix this for line diffs\r\n  private createHtml(diffs: Array<Diff>): string {\r\n    let html: string;\r\n    html = '<div>';\r\n    for (let diff of diffs) {\r\n      if (diff[0] === DiffOp.Equal) {\r\n        html += '<span class=\"equal\">' + diff[1] + '</span>';\r\n      }\r\n      if (diff[0] === DiffOp.Delete) {\r\n        html += '<div class=\\\"del\\\"> - <del>' + diff[1] + '</del></div>\\n';\r\n      }\r\n      if (diff[0] === DiffOp.Insert) {\r\n        html += '<div class=\\\"ins\\\"> + <ins>' + diff[1] + '</ins></div>\\n';\r\n      }\r\n    }\r\n    html += '</div>';\r\n    return html;\r\n  }\r\n}\r\n","import { Directive, ElementRef, Input, OnInit, OnChanges } from '@angular/core';\r\nimport { DiffMatchPatchService } from './diffMatchPatch.service';\r\nimport { Diff, DiffOp } from './diffMatchPatch';\r\n\r\n@Directive({\r\n  selector: '[processingDiff]'\r\n})\r\nexport class ProcessingDiffDirective implements OnInit, OnChanges {\r\n  @Input() left: string = '';\r\n  @Input() right: string = '';\r\n\r\n  public constructor(\r\n    private el: ElementRef,\r\n    private dmp: DiffMatchPatchService) {  }\r\n\r\n  public ngOnInit(): void {\r\n    this.updateHtml();\r\n  }\r\n\r\n  public ngOnChanges(): void {\r\n    this.updateHtml();\r\n  }\r\n\r\n  private updateHtml(): void {\r\n    this.el.nativeElement.innerHTML = this.createHtml(\r\n      this.dmp.getProcessingDiff(this.left, this.right));\r\n  }\r\n\r\n  // TODO: Need to fix this for line diffs\r\n  private createHtml(diffs: Array<Diff>): string {\r\n    let html: string;\r\n    html = '<div>';\r\n    for (let diff of diffs) {\r\n      diff[1] = diff[1].replace(/\\n/g, '<br/>');\r\n\r\n      if (diff[0] === DiffOp.Equal) {\r\n        html += '<span class=\"equal\">' + diff[1] + '</span>';\r\n      }\r\n      if (diff[0] === DiffOp.Delete) {\r\n        html += '<del>' + diff[1] + '</del>';\r\n      }\r\n      if (diff[0] === DiffOp.Insert) {\r\n        html += '<ins>' + diff[1] + '</ins>';\r\n      }\r\n    }\r\n    html += '</div>';\r\n    return html;\r\n  }\r\n}\r\n","import { Directive, ElementRef, Input, OnInit, OnChanges } from '@angular/core';\r\nimport { DiffMatchPatchService } from './diffMatchPatch.service';\r\nimport { Diff, DiffOp } from './diffMatchPatch';\r\n\r\n@Directive({\r\n  selector: '[semanticDiff]'\r\n})\r\nexport class SemanticDiffDirective implements OnInit, OnChanges {\r\n  @Input() left: string | number | boolean = '';\r\n  @Input() right: string | number | boolean = '';\r\n\r\n  public constructor(\r\n    private el: ElementRef,\r\n    private dmp: DiffMatchPatchService) {  }\r\n\r\n  public ngOnInit(): void {\r\n    this.updateHtml();\r\n  }\r\n\r\n  public ngOnChanges(): void {\r\n    this.updateHtml();\r\n  }\r\n\r\n  private updateHtml(): void {\r\n    if (!this.left) {\r\n      this.left = \"\";\r\n    }\r\n    if (!this.right) {\r\n      this.right = \"\";\r\n    }\r\n    if (typeof this.left === 'number' || typeof this.left === 'boolean') {\r\n      this.left = this.left.toString();\r\n    }\r\n    if (typeof this.right === 'number' || typeof this.right === 'boolean') {\r\n      this.right = this.right.toString();\r\n    }\r\n    this.el.nativeElement.innerHTML = this.createHtml(\r\n      this.dmp.getSemanticDiff(this.left, this.right));\r\n  }\r\n\r\n  // TODO: Need to fix this for line diffs\r\n  private createHtml(diffs: Array<Diff>): string {\r\n    let html: string;\r\n    html = '<div>';\r\n    for (let diff of diffs) {\r\n      diff[1] = diff[1].replace(/\\n/g, '<br/>');\r\n\r\n      if (diff[0] === DiffOp.Equal) {\r\n        html += '<span class=\"equal\">' + diff[1] + '</span>';\r\n      }\r\n      if (diff[0] === DiffOp.Delete) {\r\n        html += '<del>' + diff[1] + '</del>';\r\n      }\r\n      if (diff[0] === DiffOp.Insert) {\r\n        html += '<ins>' + diff[1] + '</ins>';\r\n      }\r\n    }\r\n    html += '</div>';\r\n    return html;\r\n  }\r\n}\r\n","import { NgModule } from '@angular/core';\r\nimport { CommonModule } from '@angular/common';\r\nimport { DiffDirective } from './diff.directive';\r\nimport { LineDiffDirective } from './lineDiff.directive';\r\nimport { ProcessingDiffDirective } from './processingDiff.directive';\r\nimport { SemanticDiffDirective } from './semanticDiff.directive';\r\nimport { LineCompareComponent } from './lineCompare.component';\r\n\r\nimport { DiffMatchPatch } from './diffMatchPatch';\r\nimport { DiffMatchPatchService } from './diffMatchPatch.service';\r\n\r\n@NgModule({\r\n  declarations: [\r\n    DiffDirective,\r\n    LineDiffDirective,\r\n    ProcessingDiffDirective,\r\n    SemanticDiffDirective,\r\n    LineCompareComponent\r\n  ],\r\n  imports: [\r\n    CommonModule\r\n  ],\r\n  exports: [\r\n    DiffDirective,\r\n    LineDiffDirective,\r\n    ProcessingDiffDirective,\r\n    SemanticDiffDirective,\r\n    LineCompareComponent\r\n  ],\r\n  providers: [\r\n    DiffMatchPatch,\r\n    DiffMatchPatchService\r\n  ]\r\n})\r\nexport class DiffMatchPatchModule { }\r\n"]}